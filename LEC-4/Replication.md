## 主/从复制
主/从复制,强烈的一致性

容错

* 我们希望尽管发生故障仍然可以对外进行服务
* 高可用：尽管发生某种故障服务仍然可用
* 强一致性：像client的单服务器一样,整体集群状态是一致

一旦发生故障模型：我们将如何应对？

* 独立的故障停止计算机故障
* VM-FT进一步假定一次只有一个故障
* 现场电源故障（最终重启）
* 网络分区

核心思想：Replication

* 两个或者更多服务器
* 每个副本保持服务所需的状态
* 如果一个副本失败，其他副本可以继续

示例：容错MapReduce主机

lab 1 workers已经是容错的，但是 master 存在单点问题;我们可以有两个master，万一失败了吗？worker list;哪些工作完成;哪个工人闲着;TCP连接状态;程序计数器

比较大的问题：

  * 状态如何复制？
  * 复制品如何获得状态？
  * 什么时候切断备份？
  * 在分片过程中是否有异常现象？
  * 如何修复/重新整合？

两个主要方法：
  State transfer
    master 副本执行该服务
    主要将[新]状态发送到备份
  复制状态机（Replicated state machine）
    所有副本都执行所有操作
    如果启动状态相同，
      相同的操作，
      同样的顺序，
      确定性，
      那么相同的结束状态

State transfer比较简单
  但状态可能很大，转移缓慢
  VM-FT使用复制状态机

复制状态机Replicated state machine）可以更有效率
  如果操作与数据相比较小
  但是复杂到正确
    例如在多核，决定论上的顺序
  实验室使用复制状态机

什么是复制状态机Replicated state machine）？
  K / V放好了
  x86指令？
  影响性能和易于实施
    主要和备份之间需要多少交互
      高级抽象机可以传递较少的信息
    处理非确定性在x86级别很难，但是在put / get级别上更容易
  更高级别的RSM仅适用于使用更高级别界面的应用程序
    x86 RSM可以执行任何x86程序

非常具有想法的制度(Very ambitious system)：
  全系统复制
  对应用程序和客户端完全透明
  任何现有软件的高可用性
  故障模式：
    1. 独立的硬件故障
    2. 现场电源故障

概观
  [图：应用程序，O / S，下面的VM-FT]
  两台机器，主要和备用; 和其他机器
  两个网络：客户端到服务器，记录通道
  共享磁盘用于持久存储
  在“锁定步骤”与主要备份
    主要将所有输入发送到备份
    备份的输出被丢弃
  主要和备份之间的心跳
    如果主要失败，启动备份执行！

什么是输入？
  时钟中断
  网络中断
  磁盘中断

挑战：
  1. 使它看起来像一个可靠的服务器
    如果主要的失败和副本接管，外界会看到什么？
      如果在向客户端发送响应之前或之后主要失败
      客户端的请求可能会丢失吗？执行两次？
    主要什么时候向客户发送回复？
  2. 如何避免两个初选？（“脑裂”）
    如果记录通道中断怎么办？
    主要和备份都将是初级的？
  3. 如何使备份成为主要的准确副本
    哪些操作必须发送到备份？
      时钟中断？
    如何处理非确定论？
      例如，中断必须以与初级相同的指令进行备份


挑战1解决方案：FT协议
  主要延迟任何输出，直到备份acks
    每个输出操作的日志条目
    备份后主要发送输出接收输出操作
  性能优化：
    主要执行传递的输出操作
    缓冲区输出直到备份确认

挑战2解决方案：共享磁盘
  硬问题只有不可靠的网络！
    看下周的讲座
  纸张解决方案：假设共享磁盘
    备份通过最后一个日志条目重播
    在磁盘上备份原子性测试和设置变量
      如果设置，主要仍然存在。自杀
      如果没有设置，主要死亡。成为主要
      如果是主，请从检查点创建新的备份
        使用VMotion

挑战3解决方案：确定性重播
  目标：使x86平台确定性
    想法：使用虚拟机管理程序使虚拟x86平台确定性
    两个阶段：记录和重播
  将所有硬件事件记录到日志中
    时钟中断，网络中断，I / O中断等
    对于非确定性指令，请记录附加信息
      例如，记录时间戳寄存器的值
      重播：从日志返回值，而不是实际的寄存器
  重播：交货输入按同样的顺序进行相同的指示
    如果在第n条指令执行期间传送时钟中断
    在重播期间也会在第n条指令中传送时钟中断
  给定一个事件的日志，确定性的重播重新创建虚拟机
    管理程序提供第一个事件
    让机器执行下一个事件
      使用特殊的硬件寄存器以正确的指令停止处理器
    虚拟x86在录制期间在重放期间执行相同的操作
      OS运行相同
      应用运行相同
      - >在录制过程中，重播时将产生相同的输出
  限制：不能处理x86多核处理器
    记录和重播指令的正确交错太贵了

确定性重播对VM-FT的应用：
  管理程序在主记录
    发送日志条目以通过日志记录通道进行备份
  备份时的管理程序会重播日志条目
    我们需要在下一个事件的指令下停止虚拟x86
    我们需要下一件事情
    - >备份滞后于一个事件
    
例：
  主接收网络中断
    管理程序将中断加数据转发到备份
    管理程序将网络中断提供给OS内核
    OS内核运行
    内核提供数据包到服务器
    服务器/内核写入对网卡的响应
    虚拟机管理程序得到控制并将响应放在电线上
  备份接收日志条目
    备份提供网络中断
    管理程序向其内核提供中断
    ...
    服务器/内核向网卡发送响应
    管理程序得到控制
      没有*不*在线上的回应
    管理程序忽略本地时钟中断
      它从主要时钟中断
  主要和备份获得相同的输入，最终达到相同的状态

问：为什么要将输出事件发送到备份并延迟输出，直到备份确认？
  考虑：不要记录输出事件。仅记录输入事件。
  主：
    过程网络输入
    产生输出
    主要失败
  备份无法正确复制此序列：
    最后一个日志条目是：进程网络输入
      传递给内核
    备份“活”
      它成为主要的
    硬件中断（如时钟）
      将其传递到内核（因为备份现在是现在）
    网络输入结果输出
      在硬件中断前还是之前做过主要产品的输出？
      备份不知道
        它没有中断的日志条目
    它没有输出的日志条目
      重要的是因为时钟中断可能会影响输出
  通过将启动输出事件发送到备份，备份可以正确地排序事件
    启动输出事件之前或之后的时钟中断

问：主和备份会产生相同的输出事件吗？ 
  A：是的
  主要将启动输出事件发送到备份
  主要产出
  主要失败
  备份声明主要死亡
  备份通过开始输出事件重播
  备份成为现场
  备份执行输出事件
  - >作者声称产出两次是*不是一个问题
    如果输出是网络数据包，则客户端必须能够处理重复的数据包
    如果输出写入磁盘，则将相同的数据写入两个相同的位置
      但是它们之间不可能有任何其他的写入（他们会在日志中）
      所以，应该还好
    如果输出读取到磁盘，读取相同的数据两次到内存中的相同位置
      使用反弹缓冲区来消除DMA竞争
      提供有关I / O完成中断的数据
    
问：在接收到网络输入以后，主要发生什么情况
发送相应的日志条目进行备份？
  A：网络输入 服务依靠客户端重试。
    这是合理的，因为网络可能丢失了请求数据包
  A：磁盘输入。虚拟机管理程序重新启动挂起的磁盘I / O
      
共享存储是单点故障
    如果共享存储器关闭，则服务关闭
  确定纸张的设置，但是对于地理复制服务
    地震不能生存

问：为什么共享磁盘上没有主记录日志，那么备份重播日志？
  优点：无需登录通道，无FT协议等

问：主要失败后服务不能使用多久？
  检测故障
  执行日志条目
    如果备份远远落后，VM-FT会降低主数据
  写共享存储
  切换到“活”

实施挑战：
  网络堆栈
    异步事件陷阱到管理程序
    减少通信网络输出到备份造成的额外延迟
  磁盘I / O
    DMA

表现（表1）
  FT /非FT：令人印象深刻！
    小慢下来
  记录带宽
    18 Mbit / s for my-sql
      因为备份没有从磁盘读取
      从loc盘读取：8 Mbit / s
  网络应用：FT显着限制网络带宽
    所有输入包必须转发到备份
  不够好的高性能服务？

概要：
  主从复制
    VM-FT：干净的例子
  如何处理裂脑综合征？
  如何获得更好的表现？
    使用更高级复制状态机的主后端复制键/值操作，如put和get
