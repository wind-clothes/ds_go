## BFT QA

问：今天有任何系统使用BFT协议吗？

A：BFT正在看到类似比特币的系统。比特币解决了共识与恶意参与者，但使用工作证明和长时间的延迟来解决。PBFT部署。IBM的Hyperledger使用PBFT作为其共识模块。

问：使用BFT来实施一个“被许可”的比特币是否可行，会员集是固定的？如何快速和现实（在现实世界中）会，这样的系统呢？

A：与Bitcoin一样的系统有一个有趣的连接。比特币解决了与恶意节点的共识问题，但它可以有很长的一段时间。查看Star和Hyperledger用于分类帐系统或由PBFT启发。

问：主要备份或筏是唯一需要处理的系统,拜占庭故障？还有其他系统吗？

答：任何受到威胁的电脑都可能因拜占庭而受到攻击者的控制。 

问：Google或其他公司如何处理系统中的Byzatine故障？

A：我不知道Google在做什么，但我猜测他们专注于预防并检测受损节点，而不是使用某些节点运行其系统类似BFT的协议，可以处理受损的节点。

问：拜占庭容错是一个比解决网络更难的问题;

答：BFT论文中处理与Raft相同的问题（包括处理网络）分区），但存在恶意副本。所以，PBFT算法
解决比Raft更具挑战性的问题。

问：复制品如何处理丢失的消息或无序消息？

答：消息包含足够的信息，收件人发现他们错过了一条消息或者一条消息是无序的。见第二节第四段。

问：在BFT领导层面，BFT是否遵循强有力的领导原则？具有在较弱形式的领导者设计，以允许更多的可用性？

A：BFT，像筏子，有一个指定的领导，一个视图，这决定了消息顺序。如果领导失败或不遵守协议，那就是,一个视角的变化，伴随着一个新的领导者。

在实用的BFT论文中有很多论文。该我知道的高性能有一个指定的领导; 例如，见
以下论文：
https://www.cs.utexas.edu/~lorenzo/papers/kotla07Zyzzyva.pdf

问：纸张提出的消息数量似乎是O（n ^ 2），其中n是副本数。有没有确定你需要的文献
O（n ^ 2）消息来处理拜占庭故障？

答：有大量有关BFT协议的文献。其中最有效率的,我知道是Zyzzyva
（https://www.cs.utexas.edu/~lorenzo/papers/kotla07Zyzzyva.pdf），其中推测
每个节点都是诚实的，在这种情况下发送2n个消息（见图1）。

然而，消息的数量只是BFT协议的一个因素。并且是通常不是最重要的一个，因为在许多协议中发送消息,并行或使用组播作为BFT。其他指标是服务器数量在延迟的关键路径上，每秒的消息数（可以通过批量增加，从而牺牲延迟）等等。

问：PBFT如何对MAC进行密钥管理？

A：每个客户端与每个副本共享密钥会话密钥。那就是一些额外的协议机制允许副本验证真实性
来自其他副本的2f + 1响应，这充分利用了它的存在一个小学。博士论文全文如下：
https://dspace.mit.edu/bitstream/handle/1721.1/86581/48116479-MIT.pdf


问：不要跳过序列号，不管什么？

答：我认为是正确的，虽然在一个视图中改变了一些序列号
将成为一个不起眼的

问：如何在两个不同的视图中提供给定的请求，但是相同序列号？事件的顺序如何？

A：可能会发生的是，新的小学生可能不知道一则消息承诺在以前的观点（因为它错过了）。但是，正常操作协议将保证小学生将了解到这一点,消息在视图更改协议期间，因为2f + 1好的副本有致力于在以前的观点的消息。新的小学从那时起,最后一个稳定的检查点并修复日志，插入稳定性证明为消息。然后，它变成一个新的视图。

问：非主要副本是否可以接收（并接受）准备消息*之前*它收到相应的预准备消息
主？为什么这样好吗？

答：复制品可以在看到预先准备之前了解2f + 1准备,从主要（因为乱序传递或丢失的消息），但它
会注意到它尚未见到该序列号的预先准备。一世不知道协议在这种情况下究竟是什么，但最有可能等待
为了预先准备，因为它包含日志条目本身。准备仅包含条目的摘要。

问：从第2页的底部，为什么系统必须依靠同步才能在不依赖同步来提供安全的情况下提供活力？

答：在异步分布式系统中有不可能的结果（其中消息不具有有限延迟）与一个故障节点，一个不能
在有限的时间内达成共识。这被称为FLP结果（在这里讨论FLP：
http://the-paper-trail.org/blog/a-brief-tour-of-flp-impossibility/或on
维基百科）。

PBFT作者只是指出他们没有绕过这个结果，而是假定它们是同步的弱形式（即延迟（t）
不会无限长于t）。

问：为什么PBFT最多需要1/3的故障机器，为什么不能把这个约束放松到1/2？

答：简短的答案是协议不工作，如果超过1/3节点是恶意的。他们有一个简短的证明，3f + 1是最小数量,必要的副本（见p3，第二段）。

问：本文提到确定性状态机变化以防止分歧。他们提到复制品必须能够决定性地决定值是否正确，如果不是，该怎么办？复制品如何实现这个？我明白下一段关于复制品的参与选择正确的值作为特殊情况，但在一般情况下，如何一个副本知道一个值是否正确？

答：一般情况下，需要在协议中增加一个阶段
2f + 1值，然后使用确定性计算来计算值
使用（例如，2f + 1值的中值）。作者指出，这个额外的阶段
在常见情况下可以避免，因为复制品可以检查值是否为
正确。例如，在时间戳的情况下，主要可以选择它
复制品可以通过比较时间来验证时间戳足够近
由小学提供的邮票在当地时钟的窗口内。


问：观察变化与筏子选举有关吗？我不太明白
虽然服务器如何“赢得”视图，成为主要的？

答：查看变化就像变化的筏子领导人，但没有选举。
下一个的主要是预先确定的，它是v mod n（其中v是视图
数字和n个副本的数量）。所以主要在服务器之间旋转
最多有一个错误的原色在一行（因为不超过f个节点可以
故障）。

问：系统如何决定f的值？你如何预测多少？
您希望在恶意攻击中失败的服务器？

A：这是所描述的PBFT的跟腱。在后来的作品中，作者
扩展PBFT以包括主动恢复，以便算法可以
容忍任何数量的故障在系统寿命内提供较少
复制品的三分之一在一小漏洞的窗口内变得有缺陷
（见http://dl.acm.org/citation.cfm?id=571640）。

问：在导言中，作者走出他们的方式谈论他们如何
算法是_practical_，但是稍后再说明它们唯一的限制
其网络中的每个节点应该运行不同的实现
服务代码（为了独立失败）。这是多么现实？

答：这确实是一个棘手的问题：不同的副本不能有相同的错误，因此实现必须是不同的。本文提到N版本编程，但在后来的工作中，作者使用BASE扩展了PBFT，这是一种复制技术，它使用抽象来提高其屏蔽软件错误和现有服务实现的重用的能力。它使用由正确副本存储的状态的抽象视图来定期修复每个副本，并且每个副本可以运行不同或非确定性的服务实现，这降低了共模失败的概率（参见http://dl.acm.org/citation。 cfm？id = 859718的详细信息）。

问：什么是摘要？

A：消息摘要是指计算防碰撞的结果，加密散列函数，如SHA256，消息。

问：我最近读了“最悲伤的时刻”
（https://www.usenix.org/system/files/login-logout_1305_mickens.pdf），并想知道
BFT的实际应用是什么？似乎也是环境受到控制，BFT是不必要的，也没有环境不受控制和BFT是棘手的。

A：我不知道他们是什么，但我们正在阅读论文1）因为它是一个令人印象深刻 和2）它可能会回来。例如，比特币解决了与BFT类似的问题，但长期以来一直困扰着; 也许在
未来我们将系统结合BFT和Bitcoin的想法。
