## 拜占庭容错

论文：Castro和Liskov的“实践拜占庭容错”（OSDI'99）

为什么我们读这篇文章？
  令人印象深刻
    解决比Raft更严格的问题
    即存在恶意副本的状态机复制
  许多后续论文
  BFT今天没有广泛使用
    人们依靠预防和检测受损节点
  BFT正在看到像比特币一样的系统
    比特币解决了与恶意参与者的共识
      但是，解决问题的工作和长时间的延误
    恒星推广联邦部署的PBFT
    IBM的hyperledger使用PBFT

我们考虑过许多​​容错协议
  一直假设“故障停止”故障 - 如电源故障
  即服务器遵循协议
  足够硬：崩溃vs网络下降; 网络分区

能处理更大类别的失败？
  错误的服务器，计算不正确而不是停止？
  服务器*不*遵循协议？
  受攻击者修改的服务器？
  经常被称为“拜占庭”故障

论文的方法：
  复制状态机
  假设3f + 1的2f + 1是无故障的
  使用投票选择正确的结果
  不像听起来那么容易

我们假设最坏的情况：
  单个攻击者控制f错误的副本
  并正在积极尝试打破系统
  如果我们可以处理这个问题，我们也可以处理f副本中的错误

攻击者的权力是甚么？
  提供错误的副本运行的代码
  知道非故障副本正在运行的代码
  知道错误的副本加密密钥
  可以读取网络消息
  可以暂时强制通过DoS延迟消息

什么故障不能*发生？
  3f + 1副本中的f不能超过f
  没有客户端的故障 - 客户永远不会做任何坏事
  没有猜到加密密钥或破解加密

示例使用场景：
  RM：
    回声A>等级
    回声B>等级
    告诉FK“档案档案就绪”
  FK：
    猫等级

错误的系统可以：
  完全构成文件内容
  执行write（“A”）但忽略write（“B”）
  向RM显示“B”，将“A”显示为FK
  执行write（“B”）只有一些副本

我们试图设计我们自己的拜占庭容错RSM
  开始简单（和破碎），努力走向纸张的设计

设计1：
  [客户端，n台服务器]
  n台服务器
    服务器没有相同的漏洞利用
    不同的操作系统，不同的服务实现等 
  客户端和服务器具有公钥对
    每封邮件均通过发送签名
    收件人验证消息
  客户端向所有服务器发送请求
  等待所有的n回复
    认证回复
  只有所有的人都同意的话
    
设计1有什么问题？
  一个服务器可能已被盗用
  一个服务器可以通过不同意来阻止进度

设计2：
  让我们复制投票
  2f + 1服务器，假定不超过f有故障
  客户端等待f + 1匹配回复
    如果只有f有错误，网络最终工作，必须得到他们！

设计2的2f + 1有什么问题？
  f + 1个匹配的回复可能是坏的节点，只有1个好
    所以也许只有一个好的节点得到了操作！
  *下一个*操作也等待f + 1
    可能*不*包括一个看到op1的好节点
  示例：（见下图）
    f g1 g2（f有故障/不良）
    大家听到并回复写（“A”）
    f和g1回复写（“B”），但是g2错过了
      客户端不能等待g2，因为它可能是一个故障的服务器
    f和g2回复read（），但是g1错过了
    所以read（）产生“A”
  结果：客户被骗了接受基于过期状态的回复
    例如TA从成绩文件中读取A而不是B
    例如打破正确性; 它应该提供线性化（返回B）
    
       放k = A Put k = B获取k  - > A（f表示发送A）
    C  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - - - 
           ^ ^ ^ \ ^ ^ \ ^ ^
        \ / / / \ / / \ / /
    F  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - - - 
         \ / / \ / \ /
    g1 ------------------------------------------------- - 
           \ / \ /
    g2 ------------------------------------------------- - 
            一个                         

    ==>需要确保回复包括大多数好的节点，这样
    至少有一个会稍后返回B

设计3：
  3f + 1服务器，其中最多f个故障
  客户端等待2f + 1匹配回复
    == f坏节点加上大多数好的节点
    所以所有的2f + 1组在至少一个好的节点上重叠
  示例（见下文）：
    f g1 g2 g2（f有故障/不良）
    大家听到写（“A”）
    f，g1，g2进程写（“B”），g3未命中
    现在read（）
      客户端将等待2f + 1 = 3匹配回复
      f和g3将回复“A”
      g1和g2将回复“B”
    客户不知道相信什么（也不是2f + 1）
      但是保证有一个问题
  所以客户端可以*检测*一些好的节点错过了一个操作
    我们将会看到如何修复

       Put k = A Put k = B Get k：ABBA 
    C  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - - - 
           ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^
        \ / / / / \ / / / / / / / / /
    F  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - - - 
         \ / / / / / / \ / / /
    g1 ------------------------------------------------- - 
           \ / / \ / \ / /
    g2 ------------------------------------------------- - 
            \ / \ /
    g3 ------------------------------------------------- - 

 
如何处理多个客户端？
  非故障副本必须以相同的顺序处理操作！

让我们有一个主要选择并发客户端请求的顺序
  但是我们必须担心主要的错误

主要做错什么？
  1.向客户发送错误的结果
  不同的ops到不同的副本
  3.忽略一个客户端

处理故障初级的一般方法
  1.副本将结果直接发送给客户端
  2.副本交换关于主要发送的操作的信息
  3.客户端通知每个操作的副本以及主要的
     每个复制品都会监视每个操作的进度
     如果没有进展，强制改变小学

当一个副本首次从主要接收它时，副本是否可以执行一个操作？
  否：也许主要对不同的副本给予不同的操作
  如果我们确定之前执行，我们已经破坏了副本的状态
  需要第二轮消息，以确保所有好的副本都具有相同的操作

设计4（含初级）：
  3f + 1服务器，一个是主要的，有故障的，主要的可能是错误的
  客户端向主要AND发送请求到每个副本
  主要选择下一个op和op＃
  主要将PRE-PREPARE（op，n）发送给副本
  每个副本将PREPARE（op，n）发送到所有副本
  如果副本从2f + 1个副本（包括本身）获得匹配的PREPARE（op，n）
    n是下一个操作＃
    执行操作，可能修改状态
    向客户发送回复
  其他：
    继续等待
  客户端在获得f + 1匹配回复时很高兴

    op f + 1匹配回复
    C  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - - --------------------------------------
                                                       ^ ^
        \ pre-P（op，n）PREPARE 2f + 1匹配答复p /
    p ------------------------------------------------- --------------------------------------
         \ \ ^ ^ \ ^ ^ / \ 2f + 1匹配回复/
    g1 ------------------------------------------------- -------------------------------------
           \ \ / / \ / / \ /
    g2 ------------------------------------------------- -------------------------------------
            \ \ / \ / \ /
    g3 ------------------------------------------------- -------------------------------------


记住我们的策略：
  主要遵循协议=>进度
  没有进度=>副本检测和强制改变主要

如果主要是无故障的，可以错误的副本阻止正确的进度？
  他们不能伪造主要msgs
  他们可以延迟msgs，但不能永远
  他们不能做任何事情，但它们不需要2f + 1匹配的PREPARE
  他们可以发送正确的PREPARE
    和DoS是好的副本，以防止他们听到ops
    但这些副本最终会听到小学生的操作
  最糟糕的结果：延误

如果主要是错误的，副本会发现任何问题吗？
  还是可以主要造成不可检测的问题？
  主要不能伪造客户端操作 - 签名
  它不能忽略客户端操作 - 客户端发送到所有副本
  它可以尝试以不同的顺序发送到不同的副本，
    或尝试欺骗复制品来思考操作
    即使没有加工
  将复制品检测到这样的攻击？

主要发送的结果与差异复制的差异？
  情况1：所有好的节点得到2f + 1匹配的PREPARE
    他们都是一样的吗？
    是的，每个获得2f + 1匹配的PREPARE的人都必须有相同的操作
      因为任何两组2f + 1共享至少一个好的服务器
    结果：所有好的节点将执行op2，客户端开心
  情况2：> = f + 1好节点得到2f + 1匹配准备
    再次，没有任何意见分歧
    结果：f + 1好节点将执行op，客户端快乐
    但是不能执行好的节点
      他们可以用来有效地回滚操作吗？
      即将写（“B”）发送到f + 1，将read（）发送到剩余的f
      否：将无法找到具有旧状态的2f + 1副本
      所以没有足够的PREPARE
  情况3：<f + 1个好的节点得到2f + 1匹配的PREPARE
    结果：客户端从未收到回复
    结果：系统会停止，因为f + 1卡住等待这个操作

主要故障后如何恢复运作？
  需要查看更改以选择新的主要
  （此视图更改仅选择主要;没有设置实时服务器的概念）

复制品何时要求修改视图？
  如果它看到一个客户端，但没有看到2f + 1匹配的PREPARE
  经过一段超时时间

如果只有一个副本要求，可以触发视图更改吗？
  否：错误的副本可能导致不断的视图更改

让我们推迟多少个副本必须要求的问题
  视图变化
  
谁是下一个主要的？
  需要确保错误的副本不能总是使自己成为下一个主要的
  查看数字v
  主要是v mod n
  所以主机在服务器之间转动
  最多连续发生错误的初选

查看变更设计1（不正确）
  副本发送VIEW-CHANGE请求到* new * primary
  新的主要等待足够的查看更改请求
  新主播宣布视角更改与NEW-VIEW
    包括VIEW-CHANGE请求
    作为足够的副本想要改变观点的证明
  新的主要开始编号操作，最后n看到+ 1

所有无故障的副本是否同意视图更改的操作编号？

问题：
  我看到2f + 1的PREPAREs操作n，所以我执行它
  新的小学没有，所以没有执行它
  因此新的主要可能开始在n编号，产生两个不同的op #n

可以新的主要问所有副本的执行操作集吗？
  不工作：新的主要只能等待2f + 1的回复
    错误的副本可能会回复，所以新的主要可能不会等待我

解：
  不要执行操作，直到确定一个新的主要人员会听到它
  添加第三阶段：PRE-PREPARE，PREPARE，然后COMMIT
  仅在提交后执行

操作协议：
  客户端发送op到主要
  主要向所有人发送PRE-PREPARE（op，n）
  全部发送PREPARE（op，n）
  复制后接收到2f + 1匹配PREPARE（op，n）
    将COMMIT（op，n）发送给所有
  在接收到2f + 1匹配COMMIT（op，n）
    执行op

查看更改：
  每个副本将为最近的操作发送新的主要2f + 1 PREPARE
  新的主要等待2f + 1 VIEW-CHANGE请求
  新的主要发送NEW-VIEW msg到所有副本
    完整的VIEW-CHANGE msgs
    每个操作的列表，其中一些VIEW-CHANGE包含2f + 1个PREPARE
    即最后一个视图的最终操作列表

如果一个副本执行一个操作，新的主要会知道那个op？
  副本仅在接收到2f + 1 COMMITS后执行
  也许是那些谎言，从错误的副本，谁不会告诉新的小学
  但是f + 1 COMMIT来自复制品，其中有2f + 1匹配的PREPARE
  新的主要等待来自2f + 1副本的查看更改请求
    忽略f个故障节点
    f + 1发送COMMIT，f + 1发送VIEW-CHANGE
    必须重叠

新的主要可能会省略近期的一些操作？
  否，NEW-VIEW必须包括签名的VIEW-CHANGE消息

论文也在讨论
  检查点和日志，以帮助良好的节点恢复
  各种加密优化
  通常情况下优化减少msgs的数量
  快速只读操作

超过f损坏的服务器的后果是什么？
  系统可以恢复吗？

如果客户端损坏了？

假设攻击者可能会损坏其中一个服务器
  利用错误或窃取密码，或具有物理访问权限，＆c
  为什么攻击者不能摧毁他们呢？

参考文献：
  博士论文：https：//dspace.mit.edu/bitstream/handle/1721.1/86581/48116479-MIT.pdf
  主动恢复：http://dl.acm.org/citation.cfm?id=571640>
  BASE：http://dl.acm.org/citation.cfm?id=859718
  Stellar：https://www.stellar.org/papers/stellar-consensus-protocol.pdf
  Hyperledger：https://www.zurich.ibm.com/dccl/papers/cachin_dccl.pdf
  BFT有趣的观点：https：//www.usenix.org/system/files/login-logout_1305_mickens.pdf

