## Spinnaker

阅读：“使用Paxos构建可扩展，一致和高可用性
数据存储“，由Rao，Shekita，Tata，Proc.VLDB 37，2011

我们为什么看这篇文章？
 使用Paxos构建K / V服务器的案例研究      
   与实验室3相同，除了替代Paxos / Raft
   作者使用Paxos的方式看起来很像筏
 对Paxos / Raft进行数据复制的第一篇论文
   而不是配置服务la Chubby / Zookeeper
   
几个棘手的问题
  一致性强
  完全一次的语义
  快照来缩短日志
  缩放性能

K / V服务
  放（关键，价值）
  获取（键） - >值
  三角帆的界面更加复杂

建立
  许多客户发行Put / Gets RPC
  3台服务器
  现在忽略三叉树的分片

目标
  一致性强
    表现为不重复的系统
    获取最后完成Put的读取值
  高可用性
    生存一失败
    使用3来处理分裂的大脑

一致性
  表现为不重复的系统---这是什么意思？
    如果在单机K / V服务中同时执行Put和Get如何？
    结果应该是什么？
  几个定义强一致性
  实验室3选择线性化

线性化
  如果有一个线性顺序，操作的历史h是可线性化的
  完成了以下操作：
    - 对于h中的每个完成的操作，操作返回相同的结果
      如果每个操作完成，操作的执行将返回
      一个一个按顺序h。
    - 如果操作op1在op2开始之前完成（获得响应）（调用），
      那么op1在h中的op2之前。
  说上述的另一种方法是：
     -  h的调用和响应可以重新排序以产生顺序历史;
     - 根据对象的顺序定义，顺序历史是正确的;
     - 如果一个响应在原始历史记录中的调用之前，它必须
       仍然在顺序重新排序之前。   
  例如：
    如果Put / Get同时启动，则排序是正确的
    如果Put（）在Get开始之前完成，Get（）必须看到Put（）的结果

顺序一致性
  另一个流行的定义是强一致性
    所有的排程都是按顺序排列的
    所有Puts / Gets必须与客户端顺序一致
  不保证Get获取Put的结果如果Put在Get之前实时完成
    C1：Put（k1，v0）Put（k1，v1）
    C2：Get（k1） - > v0
    时间----------> ------------> --------------> ----
  以上序列依次不一致可线性化

时间一致性
  Put（）的顺序
  Get（）可以返回任何Put（）的结果
  ==> Get（）可以返回陈旧的数据
  但是，任何队列都可以回应
    更高的可用性

可编程性与可用性
  一致性强
    更容易编程
    降低可用性
  一致性较弱
    更难的程式
    更高的可用性
  实验室坚持一致（线性化）

一致性方法：利用复制日志
  Raft为我们提供了一致的复制日志
    [修改服务器有日志]
  良好的积木，但不足以进行K / V服务
    如何使用复制日志来构建K / V服务？

计划1（打破）
  计划：
    客户发送给领导者
    领导致电Start（）
    执行Put（）
    向客户发送回复
  好：领导订单放下
  坏：领导人回应太早
    客户认为RPC成功
    但服务器发送响应后可能会失败
    =>永远不会发生
  必须等到Put（）显示在日志中

投资计划2（缓慢而不完整）
  客户全部联络人领导
  领导者将所有Puts / Gets插入到日志中
  当领导者在日志中看到一个承诺的Get（k）时，它将日志中最后一个Put（k）的值返回给客户端
    日志是一个线性历史
    开始之前完成的安装在Get之前的日志中
      看看这些Puts的结果
  坏：慢，需要扫描日志
    如果我们可以保留一张K / V地图，会很好
    更新K / V地图
    从K / V读取
  坏：如果领导在输入操作记录之前失败了？
    客户端从未收到响应。
  
计划3（打破）
  计划
    客户发送给领导者
    领导致电Start（）
      操作包含Put，args和客户端ID
      筏重复操作
    当提交到日志时，显示在applyCh上
    所有服务器都以日志顺序执行Put（）
      Put是确定性的
      所有投放应用于相同的全球订单
      服务器之间的K / V必须一致
    领导者向客户发送回复
      一旦适用客户的Put
      客户端ID正在运行
  好：快
  坏：不重试

计划4 for Put（正确，重复检测重试）
   客户端不断重试，直到服务响应
     如果失败，请尝试其他服务器
     将seqno添加到客户端请求
     当Put（）成功时，增加seqno
   服务器维护重复检测表
     当服务器从日志执行操作时：
       if！duplicate [clientid] = seqno：
          res =执行K / V
          duplicate [clientid] = res
       如果领导：
          发送重复[clientid]到客户端
   
计划1获取（破）
  计划：
    客户端发送Get到任何服务器
    服务器执行获取和回复
  好：高吞吐量
    任何服务器都可以处理Get
  坏：服务器发送陈旧值
    主要提交新值在客户端开始之前记录Get（）
    但是追随者还没有收到日志条目（可能是分区的）
    追随者将返回失效值
    不可线性化
  获取必须看到所有承诺的操作
    如果客户指定时间线一致性，Spinnaker返回失效值

计划2获取（破）
  计划：
    客户端发送获取到主
    主要执行获取和回复
  好：主要知道哪些操作已被提交到日志
  坏：主要可以返回陈旧的价值
    主要是旧的，可​​能是分区的
    另一个客户可能已经联系了新的主要和执行Put
    旧主返回陈旧值
    不可能在不重复的系统中发生
    
计划3获取
  简单解决方案
    通过日志运行Get（）操作，就像Put（）一样
    实验3这样做
  筏纸
    不要通过日志运行Get（），而是确保领导者最后一次执行操作
    新主要成为主要后添加一个空条目
    主要的ping追踪者，看看它是否仍然是处理前的主要Get（）

挑战：日志无限增长
  需要一种方法来缩短日志
  想法：快照
    日志达到​​最大大小时快照K / V表
    记住快照中包含的上一个日志序列号（LSN）
    通过LSN删除所有操作
  为什么好？
    如果所有服务器都具有一致的快照
       快照包括通过相同日志条目的所有操作
    然后恢复：
       加载内存中的最后快照
       在日志中应用新操作到快照
  挑战：服务器可能没有最新的快照
     筏子为我们处理它
     
工程挑战：制作快照
  K / V居住在筏上
  日志生活在筏
  解：
    K / V使得shapshots
    K / V告诉Raft关于shapshot，包括LSN的快照
    Raft告诉K / V在applyCh上安装快照
  为什么通过applyCh进行快照通信？
  它们在applyCh上出现在哪里？
  必须快照包含重复检测表？

工程挑战：K / V服务器与Raft库之间的协调
  K / V服务器必须有锁来保护其状态
  木筏库有锁来保护其状态
  Upcalls通过applyCh交付
  容易得到僵局 例如在主要的：
    筏子goroutine持有筏锁
      例如，收到追随者的回复
    在持有锁时发送到applyCh
      跟随者表示已经提交了一个新的日志条目
      保持锁定，因为日志条目必须按照applyCh顺序插入
    Goroutine块因为applyCh已满
    K / V层的Goroutine调用Start（）或Snapshot（）的Raft库
      库已经锁定了，所以K / V goroutine块
    没有Goroutine从applyCh读取
  需要有一个管理并发计划

一个可能的计划：
  始终以特定顺序获取锁
     例如，K / V锁定，然后筏锁
     如何处理呼叫？（从筏子到K / V的电话）
  筏：
    RPC应答处理程序永远不会写入applyCh
    将写入的单独goroutine应用于applyCh
      在写入applyCh之前释放木筏锁
      订单将可以，因为只有一个goroutine发送在applyCh上
  K / V层
    一个从应用程序读取的goroutine，并在K / V上应用操作
    在从应用程序读取之前释放K / V锁定

性能挑战：性能受复制日志限制
  所有投入操作必须通过领导
  每个Put操作需要跟随者进行复制
  想法：碎片K / V
    每个碎片的木筏实例
    不同碎片的操作可以并行进行
    =>提高K / V服务的吞吐量
  实施使用主
    主人协调碎片
    存储从键到碎片的映射
    负载平衡按键（实验4）
    Master实现了自己的Raft实例

性能挑战三角帆
  几个队列共享一个磁盘
  磁盘上的寻求缓慢
  解决方案：在不同的队列之间共享日志
  并发症：
    逻辑截断等

概要
  复制日志有用的构建块
  但不足以构建复制服务
  需要解决方案：
   确保一致性强
   确保一次性语义
   截断日志
   分片应用程序


参考
  http://www.vldb.org/2011/files/slides/research15/rSession15-1.ppt