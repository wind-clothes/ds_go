## Raft2Qa

>除了GFS主复制，还有什么用途？

您可以（并将）使用Raft构建容错密钥/值数据库。

您可以使MapReduce主机容易使用Raft。

您可以构建容错锁定服务。


>当木筏接收到读请求时，它仍然提交无操作？

第8节提到两种不同的方法。领导可以发出一个
心跳第一; 或者可能会有一个公约，领导不能
在每次心跳（租赁）之后改变已知的时间段。
实际系统通常使用租赁，因为它需要较少的租赁
通讯。

第8节说，领导人才在一开始就发出一个无操作
的术语。

>该文件指出，读取时不需要日志写入，但是之后
立即继续介绍一个不作为的技术
>得到承诺。这是矛盾吗？
考虑日志'写'？

无操作只发生在术语的开始，而不是每次阅读。


>我发现关于领导者需要提交无操作条目的行
>命令知道哪些条目承诺相当混乱。为什么
>需要这样做？

当领导人首先开始任职时，不知道哪一个
在其日志结尾处的条目被提交（并且可能
执行）由前任领导（这是图8是关于）。那
是，在新领导的日志中可能会有条目，如果
新的领导人马上就要崩溃了，下一个不会被看到
领导。

在如图2所示的筏中，如果客户端发送命令，则
领导者将承诺到日志中，这样就能迫使所有人
领导者日志中的以前的条目也被承诺（因此
保证被下一个领导看到）。

第8节结尾处的无操作文本正在谈论优化
领导者执行并回答只读命令（例如，
get（“k1”）），而不在日志中提交这些命令。例如，
对于get（“k1”），领导者只需在其键/值表中查找“k1”即可
将结果发送回客户端。如果领导刚刚开始，那么
可能在其日志结束时放置（“k1”，“v99”）。应该领导
发送“v99”回到客户端，或者领导者的密钥/值中的值
表？首先，领导不知道这个v99日志条目是否是
（并且必须返回给客户端）或不承诺（和
不能发回）。所以（如果你使用这个优化）一个新的
筏子领导者首先试图向日志提交无操作; 如果提交
成功（即领导人不会崩溃），那么领导知道
这一切之前的一切都是承诺的。


>如何使用心跳机制提供租赁（for
>只读）操作工作，为什么这需要时间
>安全（例如有界时钟偏差）？

我不知道作者究竟在想什么。也许每一个
AppendEntries RPC的领导者发出说或暗示没有其他的
领导人被允许在接下来的100毫秒当选。如果
领导者得到多数人的积极回应，那么领导可以
无需进一步处理接下来的100毫秒的只读请求
与追随者沟通。

这就要求服务器对100的定义是一样的
毫秒意味着，即它们必须具有接近的时钟
同样的费率。


>第6节中的C_old和C_new变量究竟是什么？
> 11）代表？他们是每个配置的领导者吗？

它们是旧/新配置中的一组服务器。

本文不提供详细信息。我相信这是身份
（网络名称或地址）。

>从集群C_old转换到集群C_new时，我们怎么可能
>创建一个混合群集C_ {old，new}？我真的不明白什么
这意味着。不是跟随网络配置
C_old还是C_new？如果两个网络在连接上不同意呢？

在共同共识期间（冷，新活跃），
领导者需要从冷和冷的两个服务器获得多数
Cnew的服务器。

真的不会有分歧，因为在寒冷之后，新的是承诺的
进入冷和Cnew的日志（即在联合的时期之后
共识已经开始），任何一个新的领导者在冷或Cnew是
确保看到Cold，Cnew的日志条目。


>我对本文的图11感到困惑。我不确定如何
>正好从'C_old'到'C_old，new'到'C_new'的过渡。
>为什么集群领导者不是其中的一部分的问题
>新配置，领导者一旦承诺就下台
>'C_new'日志条目？（第6节提到的第二个问题）


假设C_old = {S1，S2，S3}和C_new = {S4，S5，S6}，S1是前导者
在配置更改的开始。在最后
配置更改后，S1已经提交C_new，S1不应该
因为S1不在C_new，所以再参加了。S4，S5或S6之一
应该接管领导者。


>关于集群配置：在配置更改时间，如果
>我们不得不停止接收来自客户端的请求，那么是什么
>这个自动化配置步骤的要点？不够用
>只需1）停止接收请求2）更改配置3）
>重新启动系统并继续？


这里的挑战是确保系统是正确的，即使在那里
是在这个过程中的失败，即使不是所有的服务器得到
“停止接收请求”和“更改配置”命令
同时。任何计划都必须应付混合的可能性
没有看到或完成配置的服务器
改变 - 即使是非自动化系统也是如此。纸张
协议是解决这个问题的一种方法。


>第6节的最后两段讨论删除的服务器
通过试图选出来干扰集群
>他们已从配置中删除。
>一个更简单的解决方案是要求服务器
>他们离开配置时关闭？似乎离开了
> cluster意味着服务器可以发送或接收RPC
>集群的其余部分已经不在了，但是这篇文章没有
>假设。为什么不？为什么你可以假设服务器
>会立即关闭？

我认为现在的问题是第6节协议没有
将Cnew提交给旧服务器，它只将Cnew提交给服务器
Cnew。所以Cnew的服务器在Cnew的时候从来没有学过
从冷，新的。

这篇文章说：

  当新配置已经按照Cnew的规则进行时，
  旧配置是不相关的，服务器不在新的
  配置可以关闭。

所以也许问题只存在于这段时间之间
配置更改，管理员关闭旧设备时
服务器。我不知道为什么他们没有更自动化的方案。


>从旧的和新的中获得多数的共同之处
>配置在做选举和入场承诺时，
>如果不常见，这会影响性能有多严重？


我想，在大多数情况下，没有失败，领导者得到
两大多数立即。配置更改可能只需要一个
几次往返时间，即几十毫秒，所以要求
获得两位大将会使系统减少只有少量
的时间。配置更改可能不常见（或许是每一个）
几个月）; 几个月的延迟几毫秒似乎不是
喜欢高价钱。

>多么重要的决定是多么重要？

要求两个多数是正确的要求
涵盖了在配置过程中领导失败的可能性
更改。


>要清楚，新成员加入不投票的过程
>实体不是加快复制日志的过程，而是
而不是影响选举过程？这如何增加
>可用性？这些需要赶上的服务器不会是
>可用无论对吗？


不投票服务器的目的是允许这些服务器获得
领导者的日志的完整副本，而不会保留新的提交。该
要点是允许随后的配置更改快速。如果
新的服务器还没有几乎完整的日志，然后是领导者
在他们赶上之前，不会犯冷 没有新的
客户端命令可以在Cold，新的第一次发送之间执行
和它所承诺的时间。


>如果集群管理员没有新的配置，为什么不这样做
>它只是在提交C_new时自动删除多数，然后
当完成回归领导时？是否需要进行新的选举
过程？


这是关于第6节“第二个问题”的吗？他们的情况
描述是领导者不在新的配置中
所有。所以在Cnew承诺之后，领导不应该参与
在筏上。


>配置更改中，无表决权的成员身份如何工作
>筏的部分。该服务器状态仅在切换期间持续
>（即c_new未提交）或服务器只获得完整的投票权限
>完全“赶上”？如果是这样，他们在什么时候考虑
>“赶上”？

这篇论文没有太多细节。我想象领导不会
启动配置更改，直到要添加的服务器（
无投票权的成员）接近完全陷入困境。当领导
将AppendEntries RPC中的Cold，新日志条目发送到新的
服务器，领导者将使他们完全更新（使用图2
机械）。领导者将不能提交冷的新消息
直到大多数这些新服务器被完全赶上。一旦
冷，新的消息被承诺，这些新的服务器可以投票。


>关于“寻找可理解的共识算法”的问题（RAFT论文）
>（第6节）
>
>  - 我不反对让服务器拒绝RequestVotes小于
>最后一次心跳的最小选举超时是一个好主意（它
>有助于防止不必要的选举），但为什么他们选择
>该方法专门用于防止服务器不在配置中运行
>选举 看起来似乎更有意义的是检查一个给定的
>服务器处于当前配置。例如，在我们使用的实验室代码中，
>每个服务器都具有所有服务器的RPC地址（在当前）
>配置？），所以应该可以检查一个requestVote RPC是否来了
>从有效的（在配置）服务器，否？


我同意这篇论文的设计似乎有点尴尬，我不知道
为什么他们这样设计。你的想法似乎是合理的
初始点。一个并发症是可能有情况
Cnew的服务器在联合共识阶段是领导者，但是
当时有些服务器在Cold可能不知道共同的共识
阶段（即他们只知道冷，不冷，新）; 我们不想要
后者服务器忽视合法的领导。


共同共识何时开始，什么时候结束？联合
>共识从“C_ {o，n}”的提交时间开始？


当前领导人意识到共同的共识正在进行中
冷，新的。如果领导人没有设法执行冷，新和崩溃，
新领导人没有冷，新的在它的日志，然后联合
共识早点结束 如果一个领导人设法做冷，新，然后联合
达成共识不仅刚刚开始，而且最终会完成
领导人Cnew。

>配置日志条目可以由后续的引导者覆盖
>（假设日志条目尚未提交）？


是的，这是可能的，如果原来的领导人试图发出冷，新的
在它发生冷之前崩溃，新的。


>如何提交“C_ {o，n}”日志条目？这似乎是必须的
>复制到大多数“旧”服务器（以及“新”服务器），但是
>“C_ {o，n}”的附录立即将旧服务器转换为新的，对吧？


提交不会更改Cold或Cnew中的一组服务器。例如，
也许原来的配置包含服务器S1，S2，S3; 然后冷
是{S1，S2，S3}。也许所需的配置是S4，S5，S6; 然后
Cnew是{S4，S5，S6}。一旦Cnew提交到日志，配置
是Cnew = {S4，S5，S6}; S1，S2和S3不再是配置的一部分。


>创建快照时，使用的数据和状态为
>客户端应用程序 如果是客户端的数据，那就是这个东西
客户端本身也需要支持
>筏子上提到的修改？


示例：如果您正在构建使用Raft for的键/值服务器
复制，那么服务器中将会有一个key / value模块
存储一个键和值表。这是钥匙和价值表
这被保存在快照中。


>论文说：“如果追随者收到一个快照
>描述其日志的前缀，然后记录日志
>快照被删除，但保留快照后的条目“。
>这意味着我们可能会删除操作
>州机关。

我不认为信息会丢失。如果快照包含前缀
的日志，这意味着快照包含所有的效果
该前缀中的操作。所以放弃这个前缀是可以的。


>看起来快照比它们小的时候很有用
>应用更新的顺序（例如，频繁更新到几个
>键）。当快照与其总和一样大时，会发生什么
>更新（例如，每个更新插入新的唯一键）？有没有
在这种情况下，完成快照的成本节省？


如果快照与日志一样大，那么可能没有太多的快照
具有快照的价值。另一方面，也许是快照
以比日志更容易访问的方式组织数据，例如
排序表。那么在a之后重新启动服务可能会更快
从快照表中崩溃+重新启动，而不是从日志（你会这样做）
必须排序）。

然而，更为典型的是，日志要远远大于日志
州。

> InstallSnapshot也不会带来巨大的带宽成本？

是的，如果状态很大（例如数据库）。
但是，这不是一个容易解决的问题。你可能会想要
领导者保持足够的日志来涵盖追随者的所有常见情况
滞后或暂时离线 你也可能想要一个方法
仅转移服务器状态的差异，例如仅仅是部分
最近更改的数据库。


有人担心编写快照可能需要更长的时间
> eleciton超时，因为需要的数据量
>附加到日志？

你是对的，这是一个大型服务器的潜在问题。对于
例如，如果您要复制一个数据库的数据，并且
您的磁盘只能写入每秒100兆字节，写入
快照将需要十秒钟。一种可能性是写快照
在后台（即安排不要等待写，也许是
从子进程写入），并确保快照
每10秒创建的次数少于一次。


>在什么情况下，跟随者会收到一个快照
>自己的日志的前缀？

网络可以传递消息不正常，并且RPC处理
系统可以执行它们的乱序。所以例如，如果领导发送
日志索引为100的快照，然后是日志索引110的快照，但是
网络首先提供第二个。

>另外，如果追随者收到一个快照
>其日志的前缀，然后替换其日志中的条目
>点，这一点之后的条目是领导者没有的条目
>知道，对吧？

跟随者可能具有不在接收的快照中的日志条目
如果网络延迟快照的传送，或者领导者是否有
发出日志，但还没有承诺。

>这些条目是否有承诺？

他们可以承诺


>如何处理InstallSnapshot RPC处理重新排序，当时
>在步骤6中检查引用已压缩的日志条目？特别，
>图13中不应包含：1.5：如果lastIncludedIndex <commitIndex，则返回
>马上 或者1.5：如果已经有快照和
> lastIncludedIndex <currentSnapshot.lastIncludedIndex，立即返回。

我同意 - 对于实验3B，InstallSnapshot RPC处理程序必须拒绝陈旧
快照。我不知道为什么图13不包括这个测试; 也许
作者的RPC系统比我们的订单更好。或者也许
作者打算我们概括图13中的步骤6以涵盖这种情况。


>当领导发给我一个InstallSnapshot命令时会发生什么
>是我的日志的前缀，但我已经进行了日志压缩
>我的快照在前面？假设我的快照是安全的
>进一步向前包含较小的快照？


是的，收件人忽略InstallSnapshot是正确的
收件人已经在该快照之前。这种情况可能在实验室中出现
3，例如，如果RPC系统提供RPC故障。


>领导者如何决定哪些服务器滞后，需要发送？
>快照安装？

如果一个跟随者拒绝由于规则引起的日志索引i1的AppendEntries RPC
＃2或＃3（在图2中的AppendEntries RPC下），领导有
在i1之前丢弃其日志，然后领导将发送
InstallSnapshot而不是备份nextIndex []。


有人担心编写快照可能需要更长的时间
> eleciton超时，因为需要的数据量
>附加到日志？

你是对的，这是一个大型服务器的潜在问题。对于
例如，如果您要复制一个数据库的数据，并且
您的磁盘只能写入每秒100兆字节，写入
快照将需要十秒钟。一种可能性是写快照
在后台（即安排不要等待写，也许是
从子进程写入），并确保快照
每10秒创建的次数少于一次。


>在实际使用木筏时，快照发送的频率如何？

我还没有看到现实生活中使用筏子的分析。我想象人
使用Raft将调整它，以便很少需要快照（例如通过
领导者有很多日志条目用于更新滞后
追随者）。


> InstallSnapshot是否为原子？如果服务器部分崩溃
>安装快照，领导者重新发送InstallSnapshot
> RPC，这是像RequestVote和AppendEntries RPC这样的幂等吗？

InstallSnapshot的实现必须是原子的。

领导者重新发送快照是无害的。


>为什么需要将偏移量索引到InstallSNapshot的数据[]
> RPC，是否有与快照无关的数据？或者重叠
>以前/未来大块的同一张快照？谢谢！

完整的快照可以在多个RPC中发送，每个RPC包含一个
完整快照的不同部分（“chunk”）。偏移字段
指示完整快照中RPC的数据应该在哪里。

拷贝编写有助于创建快照的性能问题？


基本思想是为了服务器到fork（），给孩子一个完整的
内存中状态的副本。如果fork（）真的复制了所有的内存，和
国家很大，这样会很慢。但大多数操作系统
不要在fork（）中复制所有内存; 而是将页面标记为
“写时复制”，并使他们在父母和孩子中都是只读的。然后
如果尝试写入，操作系统将看到页面错误
页面，操作系统只会复制页面。
净效果通常是孩子看到其父母的副本
进程'在fork（）时的内存，但是相对较少
复制。


>什么数据压缩方案，如VIZ，ZIP，Huffman编码，
>等等是最有效的筏子快照？

这取决于服务存储的数据。如果它存储图像，为
例如，那么也许你想用JPEG压缩它们。

如果您认为每个快照可能共享很多内容
与以前的快照，那么也许你想使用某种
可以跨版本共享节点的树结构。



>快速澄清：添加一个条目作为日志计数
>执行操作？

否。服务器应该只在日志条目中执行操作
领导者表示日志条目被提交。“执行”是指
将操作移交给使用Raft的服务。在实验3中，
“执行”表示Raft将提交的日志条目提供给您
键/值软件，它将Put（键，值）或Get（key）应用于其
键/值对表。


>根据本文，服务器忽略RequestVoteRPCs
认为现在的领导者存在，但是那时候他们认为一个
目前的领导不存在，我以为他们试图自己开始
>选举。那么在什么情况下他们实际上会投票给另一个人
>服务器

>对于第二个问题，我仍然感到困惑：这是什么意思
>当它说服务器应该忽略RequestVoteRPC，当它认为
>现在的领导人存在于第6节的末尾？在什么情况下
服务器认为目前的领导不存在，但尚未开始
>选举 如果服务器认为它还没有得到心跳呢
>从服务器，但在其选举超时之前？


每个服务器等待随机选择的选举超时; 如果没有听到
从整个时期的领导，没有其他服务器已经启动
选举，然后服务器开始选举。无论服务器的选择计时器
到期前可能在任何之前从大多数或所有服务器获得投票
其他服务器的计时器到期，因此很可能赢得选举。

假设心跳间隔为10毫秒（ms）。领导发送
在10,20和30时出现心跳。

假设服务器S1在时间30没有听到心跳。S1的选择定时器
时间35时，S1发出RequestVote RPC。

假设服务器S2在时间30确实听到心跳，所以它知道
服务器当时还活着。S2将设置其选择定时器关闭
早于40时间，因为只有一个失踪的心跳表示a
可能是死了的服务器，下一次心跳不会到40岁。
当S2在时间35时听到S1'a RequestVote，S2可以忽略
RequestVote，因为S2知道它听到心跳不到一个
心跳间隔前。


>我有点混淆了“如何回滚快”的一部分
>讲义6注释（和论文的相应部分）：
>
>论文概述了5.3节结束的方案：
>如果追随者拒绝，请在回覆中加入：
>冲突条目的术语
>冲突项目的第一个条目的索引
>如果领导者知道冲突的术语：
>将nextIndex [i]移回其最后一个条目，用于冲突的术语
>其他：
>将nextIndex [i]移回追踪者的第一个索引
>
>我认为根据文件，领导者应该移动nextIndex [i]
>冲突项目的第一个条目的索引。什么是
如果领导者知道冲突的术语“意思是什么？

本文对算法的描述不完整，所以我们必须
发明自己的细节。笔记有我发明的版本;
我不知道这是作者的想法。

论文的第一个条目的索引的具体问题
矛盾的术语“是领导可能根本没有条目
冲突的术语。因此，我的笔记涵盖了两种情况 - 如果服务器
知道冲突的术语，如果没有。


>减少nextIndex在网络/性能中的权衡是什么
每次不匹配时，每次2倍？即先是1,2,4,8
>等等

领导人将超过两倍，因此必须
发送比所需更多的条目。当然图2的方法也是如此
浪费，如果一个人必须备份很多。最好的可能是实现
更准确的一点，例如针对的优化
第5.3节的结尾。


>不相关 - 你的经验教筏和派克斯斯
>对应文章的第9.1节？你的经验支持
>他们的发现？


两年前我对Paxos实验室感到非常高兴。我很漂亮
对目前的Raft实验室也很满意。拉夫特实验室更加雄心勃勃：
与Paxos实验室不同，Raft实验室有一个领导者，坚持不懈
快照。我不认为我们有任何光明的发现
第9.1节 我们没有进行并行的实验
学生和我们的Raft实验室显然更加雄心勃勃。


>  - 从学术角度来看，筏子的影响是什么
>  - 现场研究人员？它被认为是重要的，鼓舞人心的，
>  - 非增量工作？或者更多的是“好吧，这似乎是一个
>  - 自然进步，更容易教，所以让我们教
>  - 这个？


筏纸比我所了解的任何论文都要好一些
现代复制状态机技术。我觉得这启发了很多
的人建立自己的复制实现。


>该文件指出，有相当数量的筏子的实施
>在野外 有没有任何改进建议是有意义的
>包括在修订版本的算法？

这里有一个例子：

https://www.cl.cam.ac.uk/~ms705/pub/papers/2015-osr-raft.pdf