## Raft2

回想起大局：
  键/值服务为例，如实验3
  [图：客户端，k / v层，k / v表，筏层，木筏日志]
  目标：与单个非复制服务器相同的客户端可见行为
    但是尽管少数的故障/断开的服务器可用

***主题：筏子日志（实验2B）

让我们谈谈在领导者改变之后同步日志
  通常是由于前任领导人的失败

我们想要确保什么？
  如果任何服务器在日志条目中执行给定的命令，
    那么没有服务器对该日志条目执行其他操作
  （图3的国家机器安全）
  为什么？如果服务器不同意操作，那么a
    领导变更可能会改变客户可见状态，
    这违反了我们模拟单个服务器的目标。
  例：
    S1：put（k1，v1）| put（k1，v2）| ...
    S2：put（k1，v1）| put（k2，x）| ...
    不能允许两个执行他们的第二个日志条目！

崩溃后，日志怎么会不同意？
  一个领导人在将所有AppendEntries发送给所有人之前就会崩溃
    S1：3
    S2：3 3
    S3：3 3
  更糟糕的是：日志在同一条目中可能有不同的命令
    一连串领导人崩溃后，例如
        10 11 12 13 < - 日志条目＃
    S1：3
    S2：3 3 4
    S3：3 3 5

新领导人将强制登录追随者; 例：
  S3被选为第6期的新领导者
  S3发送带条目13的AppendEntries
     prevLogIndex = 12
     prevLogTerm = 5
  S2回复false（AppendEntries第2步）
  S3将nextIndex [S2]递减到12
  S3发送AppendEntries w / entry 12，prevLogIndex = 11，prevLogTerm = 3
  S2删除其条目12（AppendEntries步骤3）
  类似S1的故事，但必须回到一个更远的地方

回滚的结果：
  每个活着的追随者都会删除与领导者不同的日志尾
  那么每个活着的追随者在这一点之后接受领导的参赛

新领导人可以从前一个任期结束时回滚*承诺*条目？
  即可以从新的领导者的日志中丢失承诺的条目？
  这将是一个灾难性的老领导人可能已经对客户说了“是”
  所以：Raft需要确保当选的领导者已经提交了所有的日志条目

为什么不选择最长日志的服务器作为领导者？
  例：
    S1：5 6 7
    S2：5 8
    S3：5 8
  首先，这种情况可能发生吗？怎么样？
    第6任领导 死机重启+; 术语7的领导者 崩溃并停留下来
      两次都只在追加到自己的日志之后才崩溃
    S2领导在术语8，只有S2 + S3活着，然后崩溃
  谁应该是下一个领导者？
    S1有最长的日志，但条目8可能已经提交！
    所以新的领导者只能是S2或S3之一
    即规则不能简单的“最长日志”

5.4.1结尾解释了“选举限制”
  RequestVote处理程序只为“至少是最新的”的候选人投票：
    候选人在最后日志条目中有较高的期限，或者
    候选人具有相同的最后期限和相同长度或更长的日志
  所以：
    S2和S3不会投票给S1
    S2和S3将相互投票
  所以只有S2或S3可以领先，会强迫S1丢弃6,7
    好的，因为6,7不是多数 - >没有提交 - >没有回复发送给客户
    - >客户端将在6,7中重新发送命令

点：
  “至少是最新的”规则确保新的领导者的日志包含
    所有可能承诺的条目
  所以新的领导者不会回滚任何承诺的行为

问题（上次讲课）
  图7，顶级服务器死亡; 可以选举哪一个/ d / f？

取决于图7中谁是当选的领导者，不同的条目
  将最终承诺或丢弃
  c的6和7,7可能被丢弃或承诺
  有些将永远保持承诺：111445566

如何快速回滚
  图2设计支持每个RPC一个条目 - 慢！
  实验室测试员可能需要更快的回滚
  S1：4 5 5 4 4 4 4
  S2：4 6 6或4 6 6或4 6 6
  S3：4 6 6 4 6 6 4 6 6
  S3是第6期的领导者，S1恢复了生命
  论文概述了第5.3节结束的计划
    没有细节; 这是我的猜测 更好的方案是可能的
  如果追随者拒绝，请将此回复：
    追随者的条款在冲突的条目
    跟随者第一次入学的指标
  如果领导人知道冲突的术语：
    将nextIndex [i]移回到领导者的冲突任务的最后一个条目
  其他：
    将nextIndex [i]移回追踪者的第一个索引

***主题：持久性（实验室2C）

服务器崩溃后我们会发生什么？
  我们需要重新启动并重新加入，以准备另一个失败的服务器
  我们也想应对电源故障：所有服务器崩溃+重启
  所以每个服务器的基本状态必须在崩溃之后持续

如果服务器崩溃并重新启动，Raft会记住什么？
  图2列出了“持久状态”：
    log []，currentTerm，votedFor
  如果这些完整，Raft服务器只能在重新启动后重新加入
  因此它必须将它们保存到非易失性存储
    每次更改后保存
    在发送任何RPC或RPC回复之前
  非易失性=磁盘，SSD和c
  为什么log []？
    如果重新启动的服务器是领导者多数提交进入，
      但是忘记了，未来的领导者可能看不到提交的日志条目
  为什么currentTerm / votedFor？
    为了防止客户端为一个候选人投票，然后重新启动，
      然后在同一（或更年长的）期间投票选出不同的候选人
    可能导致两位领导同一任期

如果服务器在写入持久状态时崩溃了？

一些筏状态是挥发性的
  commitIndex，lastApplied，next / matchIndex []
  Raft的算法从初始值重建它们

持久性往往是表现的瓶颈
  硬盘写入需要10 ms，SSD写入需要0.1 ms
  RPC在1 ms以内（在单个数据中心内）
  所以我们期望100到10,000次/秒
  可以通过每个磁盘写入批量许多新的日志条目来做得更好

服务（例如k / v服务器）在崩溃+重新启动后恢复其状态？
  容易的方法：从空状态开始，重新播放Raft的整个持久日志
    lastApplied是非易失性的，从零开始，所以你可能不需要额外的代码！
  但对于长寿命的系统而言，重新播放将太慢了
  更快：使用Raft快照并仅回放日志的尾部

***主题：日志压缩和快照（实验3B）

问题：
  日志会变得巨大 - 比州机器状态大得多！
  将需要很长时间才能在重新启动时重新启动或发送到新的服务器

幸运的是：
  日志包含很多冗余，例如
     put（k1，v1）| put（k1，v2）| put（k1，v3）| ...
     所以在日志中我们不需要很多旧的东西
  日志和服务的状态几乎相当
     例如，每个服务器都有完整的键/值表的副本
  服务器不需要保持*两个*完整的日志*和*服务状态

什么限制了服务器如何丢弃日志的旧部分？
  不能忘记不承诺的条目 - 可能是领导者多数的一部分
  如果崩溃并重新启动，则需要重播提交的条目
  可能需要使其他服务器更新

解决方案：服务定期创建持久的“快照”
  [图：服务状态，磁盘上的快照，木筏日志，筏持续]
  作为特定日志条目执行的整个状态机状态的副本
    例如k / v表
  服务将快照写入永久存储（磁盘）
  服务告诉Raft它是通过一些日志索引快照
  Raft在该索引之前丢弃日志
  服务器可以随时创建快照并丢弃日志的前缀
    例如当日志增长太长时

快照和日志的关系
  快照仅反映执行的日志条目
    因此只提交了条目
  所以服务器只会丢弃提交的日志前缀
    任何不知道被提交的内容都将保留在日志中

所以服务器的磁盘状态包括：
  服务的快照直到某个日志条目
  Raft的持久日志w /以下日志条目
  该组合相当于完整日志

崩溃+重新启动会发生什么？
  服务从磁盘读取快照
  Raft从磁盘读取持久化的日志
    发送已提交但不在快照中的服务条目

如果跟随者滞后，领导者已经抛弃追随者日志的结束呢？
  nextIndex [i]将备份到领导日志的开始
  所以领导者不能用AppendEntries RPC来修复这个跟随者
  因此是InstallSnapshot RPC
  （问：为什么没有领导者只丢弃所有*服务器的条目？）

什么是InstallSnapshot RPC？图12,13
  术语
  lastIncludedIndex
  lastIncludedTerm
  快照数据

跟随者做什么/ InstallSnapshot？
  如果条件是旧的（不是现在的领导者）
  拒绝（忽略）如果追随者已经包含索引/期限
    这是一个旧的/延迟的RPC
  跟随者清空其日志，替换为假的“prev”条目
  set lastApplied to lastIncludedIndex
  在应用程序发送快照到服务
  服务用快照内容替换其k / v表

请注意，状态和操作历史大致相当
  复制协议设计人员可以选择发送或存储哪些
  例如后续复制品的最后几个操作（日志条目）
    但是对于已丢失其磁盘的副本的整个状态（快照）。
  仍然，复制修复可能非常昂贵，值得关注

问题：
  接收到的InstallSnapshot RPC可能导致状态机去
  时间倒退 也就是说，图13中的步骤8可能导致状态
  机器被复位，使其反映较少的执行操作？如果
  是的，解释这可能如何发生。如果否，解释为什么不能
  发生。

***主题：配置更改（实验室不需要）

配置更改（第6节）
  configuration =服务器集
  有时你需要
    移动到一组新的服务器，或
    增加/减少服务器数量
  人类启动配置更改，筏子管理它
  我们希望Raft在配置更改期间正确处理故障

为什么不直接的方法工作？
  假设每个服务器都有当前配置中的服务器列表
  通过告诉每个服务器来新的列表来更改配置
    使用Raft外的一些机制
  问题：他们会在不同的时间学习新的配置
  例如：想用S4替换S3
    S1：1,2,3 1,2,4
    S2：1,2,3 1,2,3
    S3：1,2,3 1,2,3
    S4：1,2,4
  OOPS！现在*两个*领导人可以当选！
    S2和S3可以选择S2
    S1和S4可以选S1

筏配置更改
  想法：“共同共识”阶段，包括*新旧配置
    任何时候，无论新老，都可以独立选择领导
  系统从Cold开始
  系统管理员要求领导切换到Cnew
  Raft具有特殊的配置日志条目（服务器地址集）
  每个服务器在自己的日志中使用最后一个配置
  一个领导人承诺冷，新鲜到大多数的冷和Cnew
  2.冷之后，新的提交，领导人Cnew向Cnew的服务器提交Cnew

如果领导人在这个过程的各个方面崩溃了怎么办？
  下个任期可以有两位领导吗？
  如果可能发生这种情况，每个领导人都必须遵守：
    A.在冷，但没有冷，新的在日志
    B.在冷或Cnew，有冷，新的在日志
    在Cnew，有Cnew在日志
  我们知道我们不能按照通常的领导人选举规则来获得A / A或C / C
  AB？不，因为B需要从冷和Cnew多数
  AC？不，因为不能进入Cnew直到冷，新的致力于冷
  BB？不，因为B需要Cold和Cnew的多数
  公元前？不，因为B需要Cnew和Cold多数

好！Raft可以切换到一组新的服务器，无风险的两个积极的领导者

***主题：表演

注意：许多情况不需要高性能。
  键/值存储可能。
  但GFS或MapReduce主机可能不会。

大多数复制系统具有类似的常见性能：
  一个RPC交换和一个磁盘写入协议。
  所以筏是消息复杂性的典型。

Raft做出了一些设计选择，以牺牲性能为简单性：
  Raft追踪者拒绝乱序的AppendEntries RPC。
    而不是在填充孔后保存使用。
    如果网络重新订购数据包很多，可能很重要。
    并使领导 - >追随者RPC流水线更难。
  快速变化的国家的快照是浪费的。
  缓慢的领导者可能会伤害筏，例如在地理复制中。

经验表明，这些对性能有很大的影响：
  磁盘写持久性。
  消息/包/ RPC开销。
  需要顺序执行记录的命令。
  只读操作的快速路径。

论文更注重表现：
  动物园管理员/ ZAB; 派克斯生活 竖琴
