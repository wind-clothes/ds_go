## P2P, DHTs, and Chord

6.824 2016讲座20：P2P，DHT和和弦

计划：
  点对点（P2P）
  BitTorrent的
  DHT方法
  弦

点对点
  [用户计算机，文件，直接xfers]
  用户计算机直接通话，实现服务
    与与中央服务器通话的用户计算机相反
  可以关闭或打开
  例子：
    Skype，视频和音乐播放器，文件共享

为什么P2P会赢？
  传播网络/缓存成本超过用户
  缺少服务器可能意味着：
    更容易部署
    更少的超载机会
    单一故障不会破坏整个系统
    更难攻击

为什么所有的互联网服务都不使用P2P？
  可能难以找到数百万用户的数据项
  用户计算机不像受管服务器那么可靠
  如果打开，可以通过邪恶的参与者攻击

结果是P2P有一些成功的利基：
  非法文件共享
    热门数据，但拥有组织没有钱
  聊天/ SKYPE
    用户无论如何 隐私和控制
  比特币
    没有自然的所有者或控制者

例如：经典的BitTorrent
  合作，流行的下载系统
  用户点击下载链接，例如最新的Linux内核分发
    获取torrent文件w /内容哈希和跟踪器的IP地址
  用户的BT客户端跟踪跟踪
    跟踪器告诉它具有下载文件的其他用户客户端的列表
  用户的BT客户端与一个或多个客户端的文件进行通信
  用户的BT客户端告诉跟踪器它现在也有一个副本
  用户的BT客户端将文件提供给他人一段时间
  点：
    提供巨大的下载b / ww / o昂贵的服务器/链接

BitTorrent也可以使用DHT而不是跟踪器
  这是今天读物的主题
  BT客户合作实施一个巨型钥匙/价值商店
  “分布式哈希表”
  关键是文件内容哈希（“infohash”）
  该值是愿意提供该文件的客户端的IP地址
    Kademlia可以存储一个键的多个值
  客户端可以（infohash）找到愿意服务的其他客户端
    并把（infohash，self）自己注册为愿意服务
  客户还加入DHT来帮助实施

为什么DHT可以成为BitTorrent的胜利？
  单个巨型追踪器，比许多跟踪器分散
    所以客户更有可能找到对方
  也许一个经典的追踪者也暴露于合法和c攻击
  不清楚BitTorrent很大程度上依赖于DHT
    大部分是经典追踪器的备份？

DHT如何工作？

可扩展DHT查询：
  键/值存储分布在数百万个节点上
  典型的DHT接口：
    put（key，value）
    get（key） - > value
  松散一致; 可能get（k）看到put（k），但不能保证
  关于保持数据活着的松散保证

为什么很难？
  数百万个参与节点
  可以广播/洪泛请求 - 但是消息太多
  每个节点都可以了解每个其他节点
    然后哈希很容易
    但是保持一个百万个节点的表是最新的很难
  我们想要适度的状态，并且中等数量的消息/查找

基本思想
  在节点上施加数据结构（例如树）
    每个节点仅引用其他几个节点
  查找遍历数据结构 - “路由”
    即从节点跳到节点
  DHT应该将get（）与之前的put（）

示例：“Chord”对等查找系统
  Kademlia，BitTorrent的一个用途来自于和弦

和弦的ID空间拓扑
  Ring：所有ID都是160位数，以环形形式查看。
  每个节点都有一个随机选择的ID

密钥ID分配给节点ID？
  密钥存储在ID等于或大于密钥ID的第一个节点上。
    接近度被定义为“顺时针距离”
  如果节点和密钥ID均匀，我们得到合理的负载平衡。
  所以键ID应该是哈希（例如bittorrent infohash）

基本路由 - 正确但缓慢
  查询在某个节点。
  节点需要将查询转发到节点“靠近”密钥。
    如果我们继续移动查询，最终我们会赢。
  每个节点都知道它的“后继者”在环上。
    n.lookup（K）：
      如果n <k <= n.successor
        返回n.successor
      其他
        前往n.successor
  即顺时针方向进行查询，直到完成
  n.successor必须正确！
    否则我们可能会跳过负责的节点
    并且get（k）将不会看到put（k）插入的数据

通过继任者前进是缓慢的
  数据结构是一个链表：O（n）
  我们可以让它更像二进制搜索吗？
    需要能够将每一步的距离减半。

日志（n）“手指表”路由：
  跟踪节点呈指数距离：
    新状态：f [i]包含n + 2 ^ i的继承者
    n.lookup（K）：
      如果n <k <= n.successor：
        返回继承人
      其他：
        n'= nearest_preceding_node（k） - 在f []
        转到n'

对于一个6位系统，也许节点8看起来像这样：
  0：14
  1：14
  2：14
  3：21
  4：32
  5：42

为什么查找现在需要log（n）跳数？
  其中一个手指必须让你大致中途到达目标

有一个二叉查找树根植于每个节点
  穿过其他节点的手指表
  这比简单地将节点排列在单个树中更好*
    每个节点作为一个根，所以没有根热点
    但总共有更多的状态

日志（n）是快还是慢？
  对于一百万个节点，它是20跳。
  如果每一跳需要50毫秒，则查找需要一秒钟。
  如果每个跳都有10％的失败机会，那就是两次超时。
  所以在实践中log（n）优于O（n）
    您可以以更多的状态/带宽为代价做更好的事情（参见手风琴DHT）。

新节点如何获取正确的表？
  一般方法：
    假设系统启动，正确路由表。
    使用路由表来帮助新节点查找信息。
    以保持正确性的方式添加新节点。
  新节点m：
    发送查找自己的密钥，到任何现有的节点。
      这产生了m.successor
    m请求其继承人的整个手指台。
  此时，新节点可以正确转发查询
  在背景中调整自己的手指表
    通过查看每个m + 2 ^ i

路由*到*新节点m现在可以工作吗？
  如果m没有做任何事情，
    查找将会在m加入之前去哪里。
    就是我的前任。
    哪个将返回它的n.successor  - 这不是m。
  所以，为了正确，m的前任需要设定继承者m。
    每个节点跟踪其当前的前身。
    当m加入时，告诉它的继任者，它的前身已经改变了。
    定期向您的继任者询问其前身：
      如果那个节点更接近你，切换到那个家伙。
    所以如果我们有xmy
      x.successor将是y（现在不正确）
      y.predecessor将是m
      x将要求其x.successor为前身
        x了解m
        将x.successor设置为m
        告诉m“x是你的前任”
        称为“稳定”
  正确的后继者足以正确查找！

并发连接怎么办？
  两个具有非常近的ID的新节点可能具有相同的后继。
  例：
    最初40岁，70岁
    50和60同时加入
    最初40，50和60认为他们的继任者是70！
    这意味着例如45的查找将产生70而不是50
    一个稳定后，40和50将学习约60
    那么40将学习约50

为了保持log（n）查找作为节点加入，
  每个人都会定期查看每个手指（每个n + 2 ^ i）

节点故障怎么办？
  假设节点出现w / o警告。比优雅的离开更严格。
  两个问题：
    其他节点的路由表指的是死节点。
    死亡节点的前身没有继任者。
  如果您尝试通过死节点路由，检测超时，视为空表条目。
    也就是通过数字方式更接近入口。
  死人继承人
    失败的节点可能就在密钥ID之前！
      所以我们需要知道它的n.successor是什么
    维持继承人的继承人：r继承人。
    查询答案是第一个现场继承人> =关键
      或转发到*任何*后继<key

在路由过程中处理不可达到的节点很重要
  “Churn”在开放的p2p网络中很高
  人们关上笔记本电脑，经常移动WiFi AP
  Bittorrent / Kademlia的测量建议查找不是很快

地理位置/网络位置 - 减少查找时间
  Lookup需要log（n）消息。
    但它们是互联网上的随机节点！
    往往会很遥远。
  我们可以通过底层网络上靠近我们的节点路由吗？
  这归结为我们是否有选择：
    如果多次正确的下一跳，我们可以尝试选择最接近的。

理念：
  填充手指表条目，收集n + 2 ^ i附近的多个节点
  也许通过向后继者问n + 2 ^ i的继承人
  使用最低ping一个作为我的手指表条目

有什么影响？
  单个跳是较低的延迟。
  但随着ID空间的增加，越来越少的选择（较低的节点密度）。
  所以最后几个跳可能会很长。 
  虽然如果你正在阅读，任何副本都会做，
    你甚至在最后还有选择。

接近程度有多快？
  1 + 1/4 + 1/16 + 1/64
  不如真正的最短路径路由

任何下行地点路由？
  难以证明独立失败。
    也许没有什么大不了的，因为没有继任者列表的地方。
  更容易欺骗我在我的表中使用恶意节点。


安全性怎么样？
  自我认证数据，例如key = SHA1（value）
    所以DHT节点不能伪造数据
    当然这是令人厌烦的有不可变数据...
  有人可以造成数百万的化妆主机加入吗？
    他们不存在，所以路由会中断？
    不要相信新节点，除非它响应ping，w /随机令牌。
  DHT节点能否声称数据不存在？
    是的，虽然也许你可以检查其他副本
  一个主机可以加入w / ID选择坐在每个副本？
    或者“加入”多次，那么大部分的DHT节点呢？
    也许你可以要求（并检查）节点ID = SHA1（IP地址）

为什么不保留完整的路由表？
  所以你可以一路走一跳吗？
  大型系统中的危险：超时或保持表格更新的成本。

如何管理数据？
  这是最受欢迎的计划。
    [图：和弦层和DHT层]
    数据管理在DHT上面，使用Chord。
  DHT不保证持久的存储
    所以插入的人必须定期重新插入，如果他们关心
    如果数据过时，可能会自动过期（bittorrent）
  DHT确实复制每个键/值项
    在ID最接近密钥的节点上，看起来会发现它们
    复制可以帮助扩展查找负载以及容忍故障
  节点加入时：
    后继者将一些键移动到它
  当节点出现故障时：
    接班人可能已经有了一个副本
    但是第r个继任者现在需要一个副本

概要
  DHT用于在大型p2p系统中查找数据
    分散似乎对负载，容错性好
  但是：安全问题很困难
  流失是一个具有挑战性的问题
  影响其他设计（如Dynamo）

参考

Kademlia：www.scs.stanford.edu/~dm/home/papers/kpos.pdf
手风琴：www.news.cs.nyu.edu/~jinyang/pub/nsdi05-accordion.pdf
Promiximity路由：https：//pdos.csail.mit.edu/papers/dhash:nsdi/paper.pdf
进化分析：http://nms.csail.mit.edu/papers/podc2002.pdf
Sybil攻击：http://research.microsoft.com/pubs/74220/IPTPS2002.pdf