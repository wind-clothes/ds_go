## ZooKeeper Qa
问：为什么只有更新请求可线性化？

答：由于作者希望读取量与服务器数量的比例，
所以他们希望他们执行一个服务器而不需要任何
与其他服务器的交互。这是以牺牲为代价的
一致性：允许他们返回陈旧的数据。

问：线性化与序列化有何不同？

答：可序列化是通常用于的正确性条件
提供交易的系统; 即支持的系统
将多个操作分组成原子操作。 

线性化通常用于没有事务的系统。
当Zookeeper纸张在其定义中引用“可序列化”时
线性化，它们只是一个串行顺序。

我们在后续论文中讨论可序列化。这是一个博客
如果你好奇，那解释差异的帖子：
http://www.bailis.org/blog/linearizability-versus-serializability/

虽然博客文章提供了精确的定义，但设计师却没有
当他们描述他们时使用这些术语时的精确度
系统，所以经常你必须从上下文中收集什么
设计师正在拍摄的正确性条件。

问：什么是流水线？

Zookeeper“管道”在客户端API中的操作（创建，
删除，存在等）。这是什么流水线的意思是这些
操作由客户端异步执行。客户端调用
创建，删除，将操作发送给Zookeeper，然后返回。
在某些时候，Zookeeper会在客户端调用回调
告诉客户操作已经完成了什么
结果是。这个异步接口允许客户端管理
许多操作：第一次发布后，可以马上发出一个
第二个，等等。这允许客户端实现高
吞吐量; 它不必等待每个操作完成
在开始第二个之前。

流水线的担心是飞行中的操作可能是
重新排序，这将导致作者谈论的问题
约2.3。如果领导人在飞行中有很多写作操作
随后写入就绪，您不希望这些操作成为
重新订购，因为其他客户可能会在之前准备好
以前的写入已被应用。确保这不能
发生，Zookeeper保证客户端操作的FIFO; 那就是
客户操作按照已发布的顺序进行应用。

问：什么意思？

答：精确的定义如下：等待实现
并发数据对象是保证任何进程都可以的数据对象
完成任何操作在有限数量的步骤，不管
其他流程的执行速度。这个定义是
在Herlihy的以下论文中介绍：
https://cs.brown.edu/~mph/Herlihy91/p124-herlihy.pdf

Zookeeper API的实现是免费的。一些
客户端可以使用Zookeeper API实现的原语是免费的
（例如，组成员资格），但其他不是（例如，锁，
屏障）。

问：实施“模糊快照”的原因是什么？怎么能
状态变化是幂等的？

答：如果作者不得不决定去做一致的快照，
Zookeeper将不得不停止所有写入将为其创建快照
内存数据库。你可能还记得GFS了
这个计划，但是对于大数据库，这可能会伤害到性能
动物园管理员认真。相反，作者去做一个模糊的快照
方案不需要在快照时阻止所有写入
制作。重新启动后，他们构建一致的快照
重播检查点启动后发送的消息。
因为Zookeeper中的所有更新都是幂等的并且已经交付
相同的顺序，重新启动后的应用程序状态将正确
重播 - 一些消息可能被应用两次（一次到状态
在恢复之前，一旦恢复），但是没关系，因为他们
是幂等的。重播将模糊快照修复为一致
应用程序状态的快照。

Zookeeper将客户端API中的操作转换为某种操作
它以交易是幂等的方式调用一个事务。对于
例如，如果客户端发出条件setData和版本
请求中的号码匹配，Zookeeper创建一个setDataTXN
其中包含新数据，新版本号和更新
时间戳 这个交易（TXN）是幂等的：Zookeeper可以
执行两次，将导致相同的状态。

问：ZooKeeper如何选择领导者？

A：Zookeeper使用ZAB，这是一个具有领导地位的原子广播系统
选举建立，非常像筏。如果你好奇的话
详细信息，您可以在这里找到有关ZAB的文章：
http://dl.acm.org/citation.cfm?id=2056409

问：Zookeeper的性能如何与其他系统相比
如Paxos？

A：它具有令人印象深刻的性能（特别是吞吐量）; 动物园管理员
将击败您实施筏子的裤子。3动物园管理员
服务器进程每秒21,000次写入。您的木筏与3台服务器
每秒执行数十次操作（假设为
用于存储的磁盘），也可能是每秒数百个
固态硬盘。 

问：订购保证如何解决竞争条件
第2.3节

如果客户端向z节点发出许多写操作，然后再执行
写到Ready，那么Zookeeper将保证所有的写入
将在写入Ready之前应用于z节点。因此，如果
另一个客户观察Ready，那么所有之前的写入都必须
已被应用，因此其他客户可以阅读信息
在z节点。

问：ZooKeeper数据库有多大？看起来像服务器一样
有很多记忆。

这取决于应用程序，不幸的是，该文件没有
报告它为不同的应用程序他们使用Zookeeper
用。由于Zookeeper适用于配置服务/主机
服务（而不是通用数据存储），但是
内存数据库似乎合理。例如，你可以
想象使用Zookeeper为GFS的主人和那么多的数据
应该适合于设备齐全的服务器的记忆，就像GFS一样。

问：什么是通用对象？

答：这是一个关于Zookeeper API的理论说明
基于Herlihy介绍的并发对象的理论：
https://cs.brown.edu/~mph/Herlihy91/p124-herlihy.pdf。我们不会
花时间在这个陈述和理论上，但如果你关心那里
这个维基百科页面上的一个温柔的介绍：
https://en.wikipedia.org/wiki/Non-blocking_algorithm。 

作者呼吁这种并行对象理论的原因是
他们声称Zookeeper提供了一个很好的协调内核
这样可以在不改变服务的情况下启用新的图元。通过
指出Zookeeper是一个普遍的对象
并发对象理论，他们支持这种说法。

问：客户如何知道何时离开障碍（第7页上方）？

A：离开障碍涉及每个客户端观察znodes
所有其他客户参与障碍。每个客户端等待
他们都要走了 如果他们都走了，他们离开了障碍
并继续计算。