## ZooKeeper Qa
问：为什么只有更新请求可线性化？

答：由于作者希望读取量与服务器数量的比例，所以他们希望他们执行一个服务器而不需要任何与其他服务器的交互。这是以牺牲为代价的；一致性：允许他们返回陈旧的数据。

问：线性化与序列化有何不同？

答：可序列化是通常用于的正确性条件提供交易的系统; 即支持的系统将多个操作分组成原子操作。 

线性化通常用于没有事务的系统。当Zookeeper纸张在其定义中引用“可序列化”时线性化，它们只是一个串行顺序。

我们在后续论文中讨论可序列化。这是一个博客如果你好奇，那解释差异的帖子：
http://www.bailis.org/blog/linearizability-versus-serializability/

虽然博客文章提供了精确的定义，但设计师却没有当他们描述他们时使用这些术语时的精确度系统，所以经常你必须从上下文中收集什么设计师正在拍摄的正确性条件。

问：什么是流水线？

Zookeeper“管道”在客户端API中的操作（创建，删除，存在等）。这是什么流水线的意思是这些操作由客户端异步执行。客户端调用创建，删除，将操作发送给Zookeeper，然后返回。在某些时候，Zookeeper会在客户端调用回调告诉客户操作已经完成了什么结果是。这个异步接口允许客户端管理
许多操作：第一次发布后，可以马上发出一个第二个，等等。这允许客户端实现高吞吐量; 它不必等待每个操作完成在开始第二个之前。

流水线的担心是飞行中的操作可能是重新排序，这将导致作者谈论的问题约2.3。如果领导人在飞行中有很多写作操作随后写入就绪，您不希望这些操作成为重新订购，因为其他客户可能会在之前准备好以前的写入已被应用。确保这不能发生，Zookeeper保证客户端操作的FIFO;那就是客户操作按照已发布的顺序进行应用。

问：什么意思？

答：精确的定义如下：等待实现并发数据对象是保证任何进程都可以的数据对象完成任何操作在有限数量的步骤，不管其他流程的执行速度。这个定义是
在Herlihy的以下论文中介绍：https://cs.brown.edu/~mph/Herlihy91/p124-herlihy.pdf

Zookeeper API的实现是免费的。一些客户端可以使用Zookeeper API实现的原语是免费的（例如，组成员资格），但其他不是（例如，锁，
屏障）。

问：实施“模糊快照”的原因是什么？怎么能状态变化是幂等的？

答：如果作者不得不决定去做一致的快照，Zookeeper将不得不停止所有写入将为其创建快照内存数据库。你可能还记得GFS了这个计划，但是对于大数据库，这可能会伤害到性能动物园管理员认真。相反，作者去做一个模糊的快照方案不需要在快照时阻止所有写入制作。重新启动后，他们构建一致的快照重播检查点启动后发送的消息。因为Zookeeper中的所有更新都是幂等的并且已经交付相同的顺序，重新启动后的应用程序状态将正确重播 - 一些消息可能被应用两次（一次到状态在恢复之前，一旦恢复），但是没关系，因为他们是幂等的。重播将模糊快照修复为一致应用程序状态的快照。

Zookeeper将客户端API中的操作转换为某种操作它以交易是幂等的方式调用一个事务。对于：例如，如果客户端发出条件setData和版本请求中的号码匹配，Zookeeper创建一个setDataTXN其中包含新数据，新版本号和更新时间戳这个交易（TXN）是幂等的：Zookeeper可以执行两次，将导致相同的状态。

问：ZooKeeper如何选择领导者？

A：Zookeeper使用ZAB，这是一个具有领导地位的原子广播系统选举建立，非常像筏。如果你好奇的话详细信息，您可以在这里找到有关ZAB的文章：
http://dl.acm.org/citation.cfm?id=2056409

问：Zookeeper的性能如何与其他系统相比如Paxos？

A：它具有令人印象深刻的性能（特别是吞吐量）;动物园管理员将击败您实施筏子的裤子。3动物园管理员服务器进程每秒21,000次写入。您的木筏与3台服务器每秒执行数十次操作（假设为用于存储的磁盘），也可能是每秒数百个固态硬盘。 

问：订购保证如何解决竞争条件第2.3节

如果客户端向z节点发出许多写操作，然后再执行写到Ready，那么Zookeeper将保证所有的写入将在写入Ready之前应用于z节点。因此，如果另一个客户观察Ready，那么所有之前的写入都必须已被应用，因此其他客户可以阅读信息在z节点。

问：ZooKeeper数据库有多大？看起来像服务器一样有很多记忆。

这取决于应用程序，不幸的是，该文件没有报告它为不同的应用程序他们使用Zookeeper用。由于Zookeeper适用于配置服务/主机
服务（而不是通用数据存储），但是内存数据库似乎合理。例如，你可以想象使用Zookeeper为GFS的主人和那么多的数据应该适合于设备齐全的服务器的记忆，就像GFS一样。

问：什么是通用对象？

答：这是一个关于Zookeeper API的理论说明基于Herlihy介绍的并发对象的理论：https://cs.brown.edu/~mph/Herlihy91/p124-herlihy.pdf。我们不会花时间在这个陈述和理论上，但如果你关心那里这个维基百科页面上的一个温柔的介绍：https://en.wikipedia.org/wiki/Non-blocking_algorithm。 

作者呼吁这种并行对象理论的原因是
    他们声称Zookeeper提供了一个很好的协调内核，这样可以在不改变服务的情况下启用新的图元。通过指出Zookeeper是一个普遍的对象并发对象理论，他们支持这种说法。

问：客户如何知道何时离开障碍（第7页上方）？

A：离开障碍涉及每个客户端观察znodes所有其他客户参与障碍。每个客户端等待他们都要走了 如果他们都走了，他们离开了障碍并继续计算。
