## Distributed Transactions

主题：
  分布式事务=分布式提交+并发控制
  两阶段提交

什么是交易？
  假设应用程序想要对数据库进行复杂的更新
    如何应对崩溃和并发？
    有很多方法来应对这个问题
    交易是方便的黄金标准，虽然昂贵
  示例 - 新帐户创建：
    begin_transaction（）
    如果“alice”不在密码表中：
      添加alice到密码表
      将alice添加到配置文件表
    commit_transaction（）
  交易必须是：
    原子：所有写入都会发生，否则，即使失败
    可序列化：最终结果就好像事务一个一个地执行
    耐用：承诺写入存活崩溃并重新启动
  这些是“ACID”属性
  应用依赖于这些属性！
  我们对*分布式*交易感兴趣

分布式提交：
  一些电脑正在合作进行一些任务
  每台电脑都有不同的作用
  要确保原子性：全部执行或无执行
  挑战：失败，表现

例：
  日历系统，每个用户都有一个日历
  想安排与多个参与者的会议
  一个服务器保存用户AM的日历，另一个服务器保存NZ
  [图：客户端，两台服务器]
  sched（u1，u2，t）：
    begin_transaction（）
    ok1 = reserve（u1，t）
    ok2 = reserve（u2，t）
    如果ok1和ok2：
      如果commit_transaction（）：
        打印“是”
    其他
      abort_transaction（）
  reserve（）调用是两台日历服务器的RPC
  我们想要原子性：既储备也不是储备。
  如果第一个reserve（）返回true，然后：
    2nd reserve（）返回false（时间不可用，或者u2不存在）
    2nd reserve（）不返回（丢失RPC msg，或者u2的服务器崩溃）
    客户在第二储备（）之前失败
  我们需要一个“分布式提交协议”

想法：暂时的变化，稍后提交或撤消（中止）
  reserve_handler（u，t）：
    如果你是免费的：
      temp_u [t] = take  - 一个临时版本
      返回真
    其他：
      返回假
  commit_handler（）：
    将temp_u [t]复制到真实的u [t]
  abort_handler（）：
    丢弃temp_u [t]

想法：单一实体决定是否提交
  确保协议
  我们称之为交易协调员（TC）
  [时间图：客户端，TC，A，B]
  客户端发送RPC到A，B
  客户端的commit_transaction（）将“go”发送到TC
  TC / A / B执行分布式提交协议
  TC向客户报告“提交”或“中止”

我们需要分布式提交协议的两个属性：
  正确性：
    如果有任何提交，没有中止
    如果有中止，没有提交
  性能：
    （因为做什么都不正确...）
    如果没有失败，并且都可以提交，然后提交。
    如果失败，尽快得出一些结论。

我们将开发一种称为“两阶段提交”的协议
  由分布式数据库用于多服务器事务
  许多分布式系统中的常见模式

两阶段提交无故障：
  [时间图：客户端，TC，A，B]
  客户端向A，B发送reserve（）RPC
  客户端发送“去”到TC
  TC向A和B发送“准备”消息。
  A和B回应，说他们是否愿意承诺。
    回应“是”，如果没有崩溃，超时，＆c。
  如果两者都说“是”，TC会发送“提交”消息。
  如果说“否”，TC会发送“中止”消息。
  A / B提交，如果他们得到一个提交消息。
    即，他们将temp_ *写入真实的数据库。

为什么到目前为止这是正确的？
  除非他们都同意，否则也不可以提交。
  至关重要的是，在作出准备后，心里都不会改变
    即使失败也不行！

失败怎么办？
  网络损坏/有损/慢
  服务器崩溃
  我们的目标是什么失败？
    修复后恢复正常操作
    即恢复，*不*可用性（因为这里没有复制）
  单一症状：期待消息时超时。
    
主机在哪里等待消息？
  1）TC等待是/否。
  2）A和B等待准备和提交/中止。

终止协议摘要：
  TC t / o是/否 - >中止
  B t / o准备， - >中止
  B t / o为提交/中止，B投票否 - >中止
  B t / o为提交/中止，B投票是 - >块

从A / B等待Yes / No时，TC超时。
  TC没有发送任何“提交”消息。
  所以TC可以安全地中止并发送“中止”消息。

等待从TC准备的A / B超时
  还没有回应准备，所以TC不能决定提交
  所以A / B可以单方面中止
  回应“不”将来准备

等待提交/中止TC的A / B超时。
  我们来谈谈只有B（A是对称的）。
  如果B投票否决，可以单方面中止。
  那么如果B投票赞成“是”呢？
  可以单方面决定中止吗？
    没有！TC可能从两者都得到了“是”
    并发出“提交”给A，但在发送到B之前坠毁。
    那么A会犯，B会中止：不正确。
  B不能单方面承诺：
    A可能会投了“否”。

所以：如果B投票是“是”，它必须“阻止”：等待TC决定。

如果B崩溃并重启？
  如果B在碰撞前发送“是”，B必须记住！
  重新启动后无法更改为“否”（因此中止）
  由于TC可能已经看过以前的是，并且告诉A承诺

因此，下属必须写入持久（磁盘）状态：
  在说“是”之前，B必须记住磁盘，包括修改的数据。
  如果B重新启动，磁盘说“是”，但没有“提交”，B必须要求TC。
    （这是问题）
  如果TC表示“提交”，则B将修改的数据复制到实际数据。

如果TC崩溃并重新启动，该怎么办？
  如果TC可能在崩溃之前发送“commit”或“abort”，TC必须记住！
    并重复，如果有人问（即如果A / B /客户端没有得到msg）。
    因此TC必须在发送提交msgs之前写入“commit”到磁盘。
  由于A / B /客户端可能已经采取行动，TC不能改变主意。

该协议是“两阶段提交”。
  *决定所有的主机达成相同的决定。
  *除非每个人都说“是”，否则不提交。
  * TC故障可能使服务器阻塞直到修复。

并发事务呢？
  x和y是银行余额
  x和y从$ 10开始
  T1正在从x转移到$ 1
  T1：
    add（x，1） - 服务器A
    add（y，-1） - 服务器B
  T2：
    tmp1 = get（x）
    tmp2 = get（y）
    打印tmp1，tmp2

问题：
  如果T2在两个add（）RPC之间运行？
  那么T2会打印11，10
  钱会被创造！
  T2应打印10,10或9,11

传统的正确定义是“可串行化”
  结果应该好像交易按某种顺序一次运行一次
  好像T1，然后T2; 或T2，然后T1
    两者的结果不同; 也可以

您可以测试特定的执行是否可序列化
  寻找产生相同结果的串行顺序。
  没有这样的订单11,10，但有10,10和9,11
  
为什么序列化对程序员有好处？
  它允许应用程序代码忽略并发
  只是写这个交易，把系统从一个合法的状态转到另一个
  在内部，交易可能会暂时违反不变量
    例如T1中途
    但是可串行化保证其他xaction不会注意到

为什么可串行化性能好？
  不冲突的事务可以并行运行
  因为如果T3和T4不冲突，*结果*来自T3 || T4
    将与T3相同，然后T4（和T4，然后T3）

如何决定是否可以并行运行两个事务？

“两相锁”是实现串行化的一种方式
  每个数据库记录都有一个锁
  锁存储在存储记录的服务器上
  交易必须在使用之前等待并获取记录的锁
    因此，add（）处理程序在使用记录x或y时隐式获取锁定
  事务持有其锁直到*后*提交或中止 

为什么要持有锁直到提交/中止？
  为什么不尽快释放记录？
  例如，为什么第一次get（）之后没有T2释放x的锁？
    T1可以在T2的get（）s之间执行
    T2打印10,9
    但这不是可序列化的执行：T1，T2和T2都不是T1

什么是锁真正在做什么？
  当事务冲突时，锁延迟一次以强制执行串行执行。
  当事务不冲突时，锁允许快速并行执行。

锁定如何与两阶段提交进行交互？
  在执行客户端请求时，服务器必须获取并记住锁定。
    所以客户端 - >服务器RPCS有两个效果：获取锁定，使用数据。
  如果服务器对TC的准备说“是”：
    必须记住锁和值崩溃+重新启动！
    所以必须在回答“是”之前将锁+值写入磁盘（在日志中）。
    如果重新启动，则从TC发出COMMIT，从磁盘读取锁+值。
  如果服务器没有对准备说“是”：
    如果崩溃+重新启动，服务器可以释放锁并丢弃新值。
      （或者在崩溃期间忘记他们）
    然后对TC的准备信息说“不”。

今天的论文：R *中的两阶段提交
  R和R *是早期的IBM DB研究项目的巨大影响力
  也许是第一篇解释两阶段提交细节的论文
  对我们来说，两个主题：
    如何忘记交易
    加快只读事务

忘记在R *的2P协议
  我对2PC的描述认为下属可以随时问TC
    TC记得所有交易的结果
    这不实用 - 服务器必须忘记旧的交易
  问题：如果下属发送关于被遗忘的xaction的查询？
  解决方案2P：
    每个下级人员向TC的COMMIT msg回复ACK
    每个下属都可以忘记
    TC等待来自所有下属的ACK
    TC可以忘记
  TC从下属收到关于未知事务的查询
    两种情况可能导致TC不了解交易：
      TC从所有下属收到ACK，然后忘记
      发送准备后，TC发生坠毁事件之前，书面提交
    如果＃1，从属日志记录一个COMMIT，所以这不会发生
    如果＃2，TC不能提交，那么TC可以回复ABORT
    ACK ==从属承诺不要问这个xaction
  下级从TC abt未知事务收到COMMIT
    （也许网络丢失了其第一个ACK）
    下属必须准备和承诺，否则
      仍然只能做好准备
    所以下属可以回复ACK

加速与R *的PA（推定中止）的只读事务
  PA为只读事务消除了一轮消息
    （这是您可以简化的许多特殊情况之一）
  我将讨论完全只读事务
  他们需要锁定，并持有锁直到完成，
    以确保r / o与r / w事务的串行化
  所以TC需要一个准备阶段来询问每一个是否仍然存在
    并在交易结束时持有锁
  PA为只读事务执行此操作：
    --prepare  - >
    < -  VOTE READ--或< -  VOTE NO  - 
  不需要第二阶段！
    下属不需要写任何东西
    下属可以安全地释放准备中的锁
      因为所有的读取都已完成
  不需要日志写入！
  TC和下属可以立即忘记！
  原因：
    在任何时候都可以放心
    所以TC和下属都不需要发送查询
    所以TC和下属不必小心保存
      崩溃信息+重启
  
2PC视角
  当事务使用多个分片上的数据时，用于分片数据块
  但它有一个不好的声誉：
    慢：多轮消息
    慢：磁盘写
    锁在准备/交付交易所上; 阻止其他xaction
    TC崩溃可能导致无限制的阻塞，锁定
  因此通常仅在单个小域中使用
    例如不是银行之间，不是在航空公司之间，不是在广泛的地区
  更快的分布式交易是一个积极的研究领域：
    降低消息和持续成本
    特殊情况下可以处理较少的工作
    广域交易
    较少的一致性，更多的应用负担

筏和两相提交解决不同的问题！
  使用木筏通过复制获得高可用性
    即当某些服务器崩溃时能够运行
    服务器都做*相同*的东西
  当每个下属做不同的事情时使用2PC
    并且*所有*必须尽其所能
  2PC不帮助可用性
    因为所有服务器必须完成任务
  筏不能确保所有的服务器都做某事
    因为只有大多数人必须活着

如果你想要高可用性*和*分布式提交？
  [图]
  每个“服务器”应该是筏复制服务
  而TC应该是筏式复制的
  在复制服务之间运行两阶段提交
  那么你可以容忍失败并仍然取得进展
  您将建立类似于此的实验室转移碎片