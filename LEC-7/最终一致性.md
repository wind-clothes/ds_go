## 最终一致性，Bayou

“管理更新巴渝的冲突，一个弱势的复制
存储系统“由Terry，Theimer，Petersen，Demers，Spreitzer，
Hauser，SOSP 95.以及来自“灵活更新传播”的一些材料
对于弱一致性复制“SOSP 97（第3.3,3.5,4.2，
4.3）。

我们为什么看这篇文章？
  它探讨了一个重要而有趣的问题空间。
  它使用一些值得了解的具体技术。

大点数：
  断开连接/弱连接操作往往很有价值。
    iPhone同步，Dropbox，git，Amazon Dynamo，Cassandra，＆c
  *断开连接意味着最终（弱）一致性。
    而且它需要工作（即订购）来达到这个目的。
  *断开的可写副本导致更新冲突。
  *冲突解决可能必须是应用程序特定的。

要记住的技术思路：
  操作日志相当于数据。
  时间戳，同步和顺序，以获得最终的一致性。
  通过写入函数的日志来解决冲突，而不是数据。
  原因一致性通过Lamport时钟时间戳。
  通过版本向量快速记录比较。

论文背景：
  20世纪90年代初
  黎明的PDA，笔记本电脑，平板电脑
    笨重但潜力很大
  他们希望设备无论连接如何都有用。
    就像今天的智能手机，平板电脑，笔记本电脑。

我们来建一个会议室调度器
  一次只允许一次会议（一间）。
  每个条目都有时间和描述。
  我们希望每个人都能看到同一组条目。

传统方法：一台服务器
  服务器一次执行一个客户端请求
  检查是否有冲突的时间，是或否
  更新数据库
  收到下一个请求
  服务器隐含地选择并发请求的顺序

为什么我们不满意中央服务器？
 我想在断开的iPhone＆c上使用调度程序
   所以需要每个设备中的DB副本。
   在任何设备上修改，以及阅读。
   “同步”设备来传播DB更改（Bayou的反熵）。
 利用间歇性连接到网络。
 与其他设备间断直接接触。

为什么不合并数据库记录？（Bayou不这样做）
 允许任何一对设备同步（同步）其DB。
 同步比较DB，查找差异，尝试采用其他设备的更改。
 需要一个相互冲突的故事，例如两次同时举行的会议。
   用户可能无法在DB合并时决定。
   所以需要自动对帐。

有很多可能的解决冲突计划。
  例如采用最新的更新，丢弃他人。
  但是我们不希望人们的日历条目简单地消失！
 
冲突理念：更新功能
  应用程序提供一个功能，而不是一个新的值。
  功能读取DB，决定如何更好地更新数据库。
  例如，如果9号会议室是空闲的，否则为10，否则为11.“
    而不仅仅是“在9点见面”
  功能可以为缺席用户做出对账决策。
  同步交换功能，而不是数据库内容。

问题：当它们到达时不能运行更新功能
  A的fn：工作人员会议在10:00或11:00
  B的fn：在10:00或11:00进行招聘会议
  X同步W / A，然后B
  Y同步W / B，然后A
  X会把A的会议在10:00，Y把A放在11:00吗？

目标：最终的一致性
  好的，X和Y最初不同意
  但在足够的同步之后，所有设备的DB应该是相同的

想法：订购更新日志
  每个设备的更新功能的有序日志。
  同步==确保两个设备具有相同的日志（相同的更新，相同的顺序）。
  DB是按顺序应用更新功能的结果。
  相同的log => same order =>相同的DB内容。
  请注意，我们依赖于两个状态表示的等价性：
    DB和操作日志。
    实验室也使用这个想法。

所有设备如何同意更新订单？
  在最初创建时为每个更新分配时间戳。
  时间戳：<T，I>
  T正在创建设备的挂钟时间。
  我正在创建设备的ID。
  订购更新a和b：
    a <b如果aT <bT或（aT = bT和aI <bI）

例：
 <10，A>：员工会议在10:00或11:00
 <20，B>：在10:00或11:00进行招聘会议
 最终的结果是什么？
   执行时间戳顺序更新功能的结果
   工作人员在10:00，在11:00工作

同步之前哪些DB内容？
  A的DB：工作人员在10:00
  B的DB：在10:00雇用
  这是A / B用户在同步之前会看到的。

现在A和B相互同步
  每个将新条目排序到其日志中，按时间戳排序
  现在都知道全套更新
  A只能运行B的更新功能
  但B已经*运行B的操作太早了！

回滚和重播
  B需要“回滚”DB，以正确的顺序重新运行两个操作

大点：日志是事实; DB只是一个优化

现在DB将最终保持一致。
  如果每个人都同步足够，
  没有人创造新的更新，
  每个设备将具有相同的有序日志，
  而每个人的DB最终都会有相同的内容。

我们现在知道足够回答这个问题。
  最初A = foo B = bar
  一个设备：将A复制到B
  其他设备：将B复制到A
  依赖检查？
  合并程序？
  所有设备为什么同意最终结果？
  
更新顺序是否与挂钟时间一致？
  也许A以[10，A>]先行（在挂钟时间）
  设备时钟不太可能完全同步
  所以B可以生成<9，B>
  B的会议优先，即使A先询问

更新顺序是否与因果关系一致？
  如果A增加一个会议， 
    那么B看到A的会议，
    那么B会删除A的会议。
  也许
    <10，A>添加
    <9，B>删除 -  B的时钟很慢
  现在删除将在添加之前订购！
  所以：设计到目前为止并不是一致的。

因果一致性意味着如果操作X可能导致
  或影响操作Y，那么每个人都应该在X之前订购X。

Bayou使用“Lamport逻辑时钟”作为因果一致性
  想要写入st时间戳
    如果设备观察E1，则产生E2，则TS（E2）> TS（E1）
  所以所有的设备都将命令E1，然后E2
  拉姆波特时钟：
    Tmax =从任何设备看到的最高时间戳（包括自身）
    T = max（Tmax + 1，挂钟时间） - 生成时间戳
  注意属性：
    E1，然后E2在同一设备上=> TS（E1）<TS（E2）
    但
    TS（E1）<TS（E2）并不意味着E1出现或导致E2

逻辑时钟解决了添加/删除因果关系的例子
  当B看到<10，A>，
    B将其Tmax设置为10，所以
    B将生成<11，B>进行删除

令人担忧的是TS可能会延迟更新
  这可能会导致我的更新结果发生变化
    用户无法确定会议时间是否为最终！
    参赛作品“暂定”
  如果每个更新最终变得“稳定”，会很好
    =>在这一点上，更新顺序没有变化
    =>写功能的效果现在固定，例如会议时间不会改变
    =>不必回滚，重新运行提交的更新

想法：完全分散的“提交”计划（Bayou不这样做）
  <10，A>如果我不会看到新的更新w / TS <= 10是稳定的
  一旦我从*每个*设备看到更新w / TS> 10
    我永远不会看到任何新的TS <10（同步以TS顺序发送更新）
    然后<10，A>是稳定的
  为什么Bayou不使用这种分散的承诺方案？

想法：Bayou的“主要副本”提交更新。
  一个设备是“主要副本”。
  每个接收到的更新都使用提交序列号（CSN）进行标记。
    该更新被提交。
    所以一个完整的时间戳是<CSN，local-time，device-id>
    未提交的更新在所有提交的更新（即具有无限的CSN）之后。
  CSN通知在设备之间同步。
 
为什么commit / CSN方案最终会产生稳定性？
  主要只分配增加的CSN。
  设备日志在任何w / o CSN之前使用CSN命令所有更新。
  所以一旦更新有一个CSN，以前的更新集是固定的。

将提交订单匹配临时订单？
  经常。
  同步按日志顺序发送（“前缀属性”）
    包括从其他设备学到的更新。
  所以如果A的更新日志说
    < - ，10，X>
    < - ，20，A>
  A将按照该顺序发送到主要的
    主要将以该顺序分配CSN
    在这种情况下，提交订单将匹配临时订单

将提交订单*总是*匹配临时订单？
  否：主要可能会在较旧版本之前看到较新的更新。
  A只有：< - ，10，A> W1
  B只有：< - ，20，B> W2
  如果C同时看到，C的顺序为W1 W2
  B与主要同步，W2获得CSN = 5。
  稍后A与主要同步，W1获得CSN = 6。
  当C与主同步时，C将看到订单更改为W2 W1
    <5,20，B> W2
    <6,10，A> W1
  所以：提交可能会改变秩序。
  
提交允许应用程序告诉用户哪些日历条目不会更改。

Bayou如何同步（这是反熵）？
  送到B
  B需要一个快速的方式告诉A发送什么
  前缀属性简化同步（即同步始终按照日志顺序）
    所以B有意义的是说“我有一切...”
  承诺的更新很容易：
    B将其最高的CSN发送给A
    A在B的CSN和A的CSN之间发送日志条目（如果有的话）
  暂时更新怎么办？
  A有：
    < - ，10，X>
    < - ，20，Y>
    < - ，30，X>
    < - ，40，X>
  B有：
    < - ，10，X>
    < - ，20，Y>
    < - ，30，X>
  在同步开始时，B告诉A“X 30，Y 20”
    即，对于每个设备，最高的TS B从该设备看到。
    同步前缀属性表示B在30之前具有所有X更新，所有Y在20之前
  A在< - ，30，X>之后发送所有X的更新，< - ，20，Y>和＆c之后的所有Y的更新
  “X 30，Y 20”是一个版本矢量 - 它总结了日志内容
    这是图4中的“F”向量
    A的F：[X：40，Y：20]
    B的F：[X：30，Y：20]

设备可以从日志丢弃提交的更新。
  （很像筏子快照）
  相反，保留数据库的副本作为最着名的CSN。
  重播暂定更新日志时，回滚到该数据库。
  永远不需要回滚更远。
    前缀属性保证见CSN = x =>看到CSN <x。
    在已更新之间没有更新更新顺序。

如果我丢弃了部分日志，我如何同步？
 （很喜欢Raft InstallSnapshot RPC）
 假设我已经把所有的CSNs更新都丢弃了。
 我保留稳定数据库的副本反映只是丢弃的条目。
 如果同步到设备X，并且其最高的CSN小于我的：
   发送X我的完整数据库。
 在实践中，Bayou设备保留最后几个提交的更新。
   减少在同步期间发送整个数据库的可能性。

我们如何应对新的服务器Z加入系统？
  只能开始生成写入，例如< - ，1，Z>？
  其他设备刚开始包括Z在VV？
  如果A同步到B，A有< - ，10，Z>，但B在VV中没有Z
    A应该假装B的VV是[Z：0，...]

当Z退休（离开系统）时会发生什么？
  我们想停止在VV中包含Z！
  如何宣布Z不见了？
    Z发送更新< - ，？，Z>“退休”
  如果您看到退休更新，请从VV中省略Z
  如何处理缺少Z的VV？
  如果A具有来自Z的日志条目，但B的VV没有Z条目：
    例如A有< - ，25，Z>，B的VV只是[A：20，B：21]
    也许Z已经退休了，B知道A没有
    也许Z是新的，A知道，B不
  需要一种消除歧义的方法：Z从VV b / c新的，或b / c退休？

巴约退休计划
  Z通过联系一些服务器X来加入
  Z的ID是<Tz，X>
    Z是X加入时的逻辑时钟
  X问题< - ，Tz，X>：“新服务器ID = <Tz，X>”

ID = <Tz，X>方案如何帮助消除新的vs被遗忘？
  假设Z的ID是<20，X>
  A同步到B
    A具有从Z < - ，25，<20，X >>的日志条目
    B的VV没有Z入场 -  B从未见过Z，还是已经看到Z的退休了？
  一例：
    B的VV：[X：10，...]
    10 <20意味着B还没有看到X的“新服务器Z”更新
  另一种情况：
    B的VV：[X：30，...]
    20 <30意味着B一旦知道Z，然后看到退休更新

下一个：具有最终一致性的真实数据库。