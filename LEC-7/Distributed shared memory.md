## Munin分享共享记忆

今天：分布式计算
  大想法：你在一个充满便宜的电脑的房间里的巨大计算机！
    而不是一个大而昂贵的共享内存多处理器
    今天：数据中心集群与许多廉价的共享内存多处理器
  一个老而艰巨的目标 许多方法 进步很大 还热
    其他集群计算论文：MapReduce，Spark

为什么穆宁纸？
  分配共享内存是一个有趣的想法
    6.824中最受欢迎的项目主题
  关于分布式共享内存系统的大量文献
    这篇文章是其中之一
      软件懒散发一致性（由论文引进）
  软件工件本身没有影响力，但帝斯曼的想法是

分布式共享存储器（DSM）
  DMS在分布式系统上提供共享内存的错觉
  你们都知道如何编写并行（线程）Go程序
  让我们把线程搞成一大堆机器！
  少了什么东西？共享内存！

帝斯曼计划：
  程序员编写并行程序：线程，共享变量，锁和＆c
  DSM系统将线程导出到一组机器
  帝斯曼系统创建单个共享内存的错觉
  [图：LAN，机器w / RAM]

帝斯曼的优势
  熟悉的模型 - 共享变量，锁和＆c
  通用目的（与MapReduce和Spark相比）
  可以使用为多处理器编写的现有应用程序和库
  LAN上的大量机器比大型多处理器便宜得多

但：
  LAN上的机器实际上并不共享内存

通用DSM方法（但缓慢）：
  Munin论文中的“常规”模式
  使用硬件的虚拟内存保护（r / w vs r / o vs invalid）
  一般想法用2台机器说明：
     部分地址空间从M0开始
    在M1上，标记为无效 
     部分地址空间从M1开始
        在M0上，标记为无效
  M1上的应用程序的线程可以指存在于M0的地址
    如果线程LD / ST为“共享”地址，则M1的硬件将出现页面错误
       因为页面被标记为无效
    操作系统将页面错误传播到DSM运行时
    DSM运行时可以从M0获取页面
    DSM在M0上，标记页无效，并将页面发送到M1
    M1上的DSM从M0接收它，将其复制到底层物理内存
    DSM上的DSM标记页面有效
    DSM从页面错误处理程序返回
    硬件重试LD / ST
  运行线程代码w / o修改
    例如矩阵乘法，物理模拟（例如SOR），排序

挑战：
  内存一致性模型（记忆程序是否像程序员所期望的那样）？
    阅读观察结果如何？
    最后写？
    陈旧数据？
  表演（是快吗？）

例：
  x和y开始= 0
  线程0：
    x = 1
    如果y == 0：
      打印是的
  线程1：
    y = 1
    如果x == 0：
      打印是的

如果两个线程都打印了，是否可以？
  使用一般方法的结果是什么？
  是否有可能两个线程打印“是”？
  如果这是Go程序，他们可以打印“是”吗？
    怎么会发生？
    为什么允许？

传统方法提供了很强的一致
  我们不太在意具体的定义（通常很技术性）
  我们关心的是一贯的一般概念，
    对于提供它的论文（或不提供）和实验3
    
我们在强烈的一致性中寻找什么？
  我们希望复制系统的行为就像一个不复制的系统
    如果客户端1调用ST并且完成，然后客户端2的LD必须看到ST
    如果每个呼叫是顺序的（当时一个）
      一个一个一个的序列看到其前辈的更新
  一个有趣的情况：并行操作
    LDs和ST开始大致相同，执行重叠
    在这种情况下强一致性：
      一组并发操作后的返回值和更新状态必须相同
      如果操作按照某种顺序执行一次

你已经看到很多这样一个强大一致性基本思想的改进
   可线性化和顺序一致（简单的读写）
   可序列化和严格可序列化（用于多步交易）。
   在这个课上，我们不用担心细节差异。
  
主要权衡一致性模型
  Lax模型=>更大的优化自由度
    发送更少的消息，等待更少的响应等
  严格模型=>匹配程序员的直觉（例如，看到最新的写入）
  这种权衡是许多设计中的一个重要因素

Munin：帝斯曼案例研究
  软件版本一致性
    Go不像Go的内存模型
  特定共享模式的优化实现
    只读
    写共享
    生产者消费者

穆宁高层次的目标？
  更好的DSM性能比传统
  运行现有的并行代码

以前的DSM有什么具体问题，他们正在修复？
  虚假共享：两台机器在同一页上r / w不同的vars
    M1写入x，M2写入y
    M1写x，M2只读y
    问：在这种情况下传统方法是做什么的？
  写入放大：一个字节写入变成一个整页传输

第一个目标：消除写入放大
  不要发送整页，只写字节

大想法：写diff
  在M1写故障：
    告诉其他主机无效，但保持隐藏副本
    M1也隐藏副本
  M2故障：
    M2要求M1进行最近的修改
    M1“diffs”当前页面与隐藏副本
    M1发送差异到M2（和所有机器w /本页的副本）
    M2将差异应用于其隐藏副本
    M1标记页面r / o

问：写差异更改一致性模型？
   最多可以写一个可写的副本，所以写入是有序的
   任何副本都不可读，所以没有陈旧的读写
   可阅读的副本是最新的，所以没有陈旧的读物
   仍然顺序一致

问：写diffs修复虚假共享？

下一个目标：允许多个读者+作家
  以应付虚假分享
  =>机器写入时不要使其他人无效
  =>别的机器读取时不要将作者降级为r / o
  =>多个*不同*一个页面的副本！
     读者应该看看吗？
  diffs help：可以将写入合并到同一个页面
  但是什么时候发送diff？
    没有无效 - >无页面错误 - >什么触发发送差异？

大想法：释放一致性（RC）
  没有人应该读取数据w / o拿着锁！
    所以让我们假设一个锁服务器
  发出写差异发布
    到*所有*机器具有书面页面的副本

示例1（RC和虚假共享）
x和y在同一页上
M0：a1 for（...）x ++ r1
M1：a2 for（...）y ++ r2 a1 print x，y r1
RC做什么？
  M0和M1都可以缓存可写的页面副本
  在发布期间，每个计算与原始页面的差异，
    并将其发送到所有副本
  M1的a1使它等到M0的释放
    所以M1会看到M0的写作

问：RC的性能优势是什么？
   常规方法对实施例1有什么作用？
   即使在1次或多次写入时，多台机器也可以具有页面的副本
   =>由于虚假共享，不会弹出页面
   =>阅读副本可与作者共存

问：RC是否改变一致性模型？是！
   M0将不会看到M0的写入，直到M0释放锁
   即M1可以看到一个陈旧的x的副本; 不可能的一般方法
   如果你总是锁定：锁定强制命令 - >没有陈旧的读取

问：RC是没有写差错的吗？
   可能不是：需要diff来协调并发写入同一个页面

问：如何确定哪些机器发送差异？
   任何具有页面副本的计算机都必须看到差异
   生产者 - 消费者优化将页面限制为生产者和消费者

性能？
  表3和表4
    DSM性能类似于手写消息传递版本
  优化有多重要？
    表6表明它们是重要的
    但不是100％清楚
      一个更好的copyset可能会有生产者 - 消费者对SOR不重要？

帝斯曼发生了什么事？
  集群方法是一个好主意
  定位*现有的*线程代码不是一个长期的胜利
  被MapReduce和继承者所颠覆
    MR容忍故障
    MR指导程序员对数据和计算的良好分割
    但是对于许多并行任务，人们发现MR太僵硬了
  这里没有说出最后一句话
    最近关于灵活内存的集群编程模型的最近的工作
    例如，Spark（见周四的论文）

参考
 http://www.bailis.org/blog/linearizability-versus-serializability/
 http://www.bailis.org/blog/understanding-weak-isolation-is-a-serious-problem/
 https://aphyr.com/posts/313-strong-consistency-models
 https://www.microsoft.com/en-us/research/publication/replicated-data-consistency-explained-through-baseball/