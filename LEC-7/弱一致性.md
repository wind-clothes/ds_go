## 弱一致性 PNUTS

Cooper等人，PNUTS：Yahoo！的托管数据服务平台。VLDB 2008。

为什么这篇文章？
  介绍“地理复制”
  一个轻松一致的现实世界案例研究

那个设定
  拥有世界各地数据中心（“区域”）的网站
    用户通过联系最近的地区看到更好的表现
  每个区域存储所有数据的副本
    用户个人资料，消息，购物车，朋友列表＆c
    Web服务器可以快速读取/写入本地副本
    更好的容错，例如全数据中心电源故障

大事实
  长途通信缓慢
    海岸到海岸的往返互联网是> 50ms
    30ms的是光速
  如果你想要一致性，很难使读写速度更快
  我们可以快速读取或写入
    保留许多副本
    读或写最近的副本
  但是我们不能快速读取和写入
    如果我们只读最近的副本，写入必须写入所有副本
    如果我们只写最近的，读取必须全部读取
  读取或写入都必须很慢
    或者我们必须牺牲一致性
  PNUTS（和许多其他人）与这个真相斗争

PNUTS设计概述
  [图：3个区域，浏览器，网络应用程序，路由器，SU，MB]
  每个区域都具有所有数据的完整副本
  每个表由密钥存储单元分隔
    路由器知道分区计划

为什么所有地区的*所有*数据的副本？
  所以任何用户都可以快速阅读
    适用于许多用户/许多地区使用的数据
    跨区读取速度将会很慢（〜100ms）
  所以失败的SU可以从不同地区的副本进行修复

每个区域的副本的缺点？
  更新需要发送到每个地区
  本地读取可能会过时
  需要整理相同数据的并发更新
    保持副本相同
    不要丢失更新（例如，读取 - 修改 - 写入计数器）
  使用更多的磁盘空间

更新如何工作？
  应用服务器获取Web请求，需要在PNUTS中写入数据
  需要更新每个地区！
  为什么不只有应用程序逻辑发送更新到每个地区？
    如果应用程式在更新一些地区后崩溃了怎么办？
    如果同时更新同一记录怎么办？

PNUTS每个记录都有“记录主”
  主人是一个地区
  所有网络应用程序通过记录的主MB发送记录的更新
  主MB选择发送写入所有区域的顺序

为什么每个记录的主人？
  （为什么不是所有数据的同一主机？）
  记录通常主要由单个用户读取/写入
  PNUTS试图使记录的主人成为靠近用户的区域
  从而快速写入
  每个记录都有一个隐藏的列表示记录主区域

完整的更新故事
  （很多猜测，纸不解释）
  应用程序想要更新记录，知道密钥
  应用程序向本地路由器发送更新
  2.路由器转发到本地SU的密钥
  SU查找关键字：区域R2的记录主
  SU发送更新请求到R2的MB
  2. R2的MB存储在磁盘+备份MB上
  MB在每个区域向MB发送更新
  7.每个区域（包括R2）更新本地副本（MB  - >路由器 - > SU）
  8. SU中的SU在应用中回复新版本＃

第5步是提交点
  并且它是选择写入记录的顺序的主MB

为什么R2中的SU回复应用程序？
  为什么没有write（）返回，一旦承诺掌握MB？
  *确保read-latest看到任何已完成的写入
  * SU返回新的版本号，为后续读取关键所需
  * SU返回test-and-set-write成功/失败

MB是一个整洁的想法
  atomic：更新所有副本，否则
    而不是应用服务器更新副本（崩溃...）
  可靠：日志到磁盘，不断发送msgs，以应对各种故障
  命令：记录的副本最终相同甚至w /多个作家
  async：写入不需要等待所有区域，只需要掌握MB

写命令语义
  假设表中的每个记录如下所示：
    名称在哪里
    爱丽丝回家睡觉
  PNUTS保留对每条记录的写入次序
    例如爱丽丝
      写（爱丽丝，清醒）
      写（爱丽丝，工作）
    写RPC只有在提交到记录master的MB之后才返回
    读者可能会看到家庭/睡觉或家庭/醒来或工作/清醒
    没有人会看到工作/睡觉
    所有副本（区域）以相同的顺序应用写入
    “时间一致性”
  但是写入不同的记录不会维持顺序
    例如
      写（Bob.What，值班）
      写（爱丽丝，不负责任）
    读者可以按这两种顺序进行
      即没有人值班; 或两个值班人员
    如果原子传递很重要，需要一个人名记录

写的很复杂，需要一段时间才能完成，为什么还好？
  基本的好处：读取的时间非常快，从本地开始
    并且读取通常大大超过写入
  PNUTS缓解写延迟：
    应用程序等待MB提交而不是传播（“异步”）
    主人可能是本地人（他们声称80％的时间）
      所以MB提交通常会很快
  仍然，eval说如果master是远程的，写入需要300ms！
  非主要地区的读者可能会看到陈旧的数据

非主要记录如何陈旧？
  取决于MB向区域发送更新的速度
  猜测：通常不到一秒钟
    网络速度较慢/片长，或MB繁忙

应用程序如何应对潜在的过时本地副本？
  有时候陈旧就好了：看别人的个人资料
  有时陈旧不行：购物车后添加/删除项目
  应用程序可以选择一致（第2.2节）
  读任何（k）的
    从本地SU读
    快速但可能过时
  read-critical（k，required_version）
    = local_version
    否则从主SU慢读
    为什么：应用程序知道它只是写，想要反映写入的价值
  读最新的（K）
    保证看到任何完成的写
      因此每个记录强烈的一致性
    从主SU读
      并且取决于写入不返回，直到主SU被更新
    慢如果主人是遥远的！

如果应用程序需要增加存储在记录中的计数器，该怎么办？
  是最新的（k），增量，然后写（k）够吗？
  不是如果可能有并发更新！

test-and-set-write（version＃，new value）可以将原子更新提供给一个记录
  SUs拒绝写如果当前版本＃！= version＃
  所以如果并发更新，会丢失并重试 
  而（1）：
    （x，ver）= read-latest（k）
    if（tasw（k，ver，x + 1））
      打破
  tasw对于单记录原子读取 - 修改 - 写入是完全一般的

为什么不是原子多记录写？
  例如银行转帐：爱丽丝 -  = $ 10; Bob + = $ 10
  那会很容易添加到PNUTS？
  不：似乎要求单主，不记录每个记录

问题
  示例1中的潜在问题是什么？
    Alice的配置文件记录包含ACL和图片列表
    爱丽丝将她的妈妈从ACL中删除 
    爱丽丝添加图片列表
    最终的一致性可能会首先执行第二次写入
    妈妈可以（短暂地）看到图片
  PNUTS如何解决这个问题？
    时间线一致性
    PNUTS保证所有副本以有序的顺序执行两次写入
  PNUTS解决方案要求两个项目都在同一个记录中
    如果ACL和列表在不同的记录中，则时间线一致性没有帮助
  PNUTS解决方案需要妈妈阅读爱丽丝的记录只有一次
    没有一个读取ACL，稍后读取图片列表

如何改变记录的主人（如果没有失败）？
  例如我从波士顿搬到洛杉矶
  也许只是更新记录，通过老主人？
    由于主区域的ID存储在记录中
  老师宣布改变MB
  一些客户端可能会尝试向旧的主SU发送写入
    它会拒绝他们，应用程序重试并找到新的主人

怎么容忍失败？

应用服务器通过一组更新中途崩溃
  不是一个事务，所以完成的写入将会发生
  但是主SU / MB没有或没有得到每个写
    所以每个写入都发生在所有区域，也可以不发生
  应用程序可能需要注意写入顺序

SU短暂，或网络暂时破损/有损
  MB继续尝试直到SU acks
  SU不应该在安全地在磁盘上确认
  所以在SU重启之后，MB会使它赶上
  SU必须忽略MB的重复写入

SU永远不会重新启动，也许是由于磁盘故障
  将其平板电脑散布在其他SU上
  需要从其他地区的SU获取平板电脑内容
    1.订阅MB feed，并保存写入
    2.从另一个地区的SU复制平板电脑
    3.重播已保存的MB写入
  难题： 
    如何确保我们没有错过此SU的任何MB更新？
      例如在时间= 100时订阅MB，但源SU只能看到90？
    3.2.2中的检查点消息必须解决这个问题; 不清楚怎么样

MB接受更新后崩溃
  在两个MB服务器上记录到磁盘，然后再确认
  MB恢复查看日志，（重新）发送已记录但未被确认的msgs

记录的主区域丢失网络连接
  我们可以将记录的主人变成另一个地区吗？
    否：原始主MB可能已经记录和确认更新，尚未发送
  所以应用程序必须等待区域恢复才能写入
    这是有序更新的一个价格

现在表现

评估侧重于延迟，而不是吞吐量
  为什么延迟？
  为什么不吞吐量？
  可能通过添加更多的SU无限期地增加吞吐量
  而延迟更难减少

大性能问题：为什么MB不是一个可怕的瓶颈？
  所有写入漏斗通过几MB
  它记录每个写入磁盘 - 每个磁盘写入10ms
  纸张没有说明PNUTS如何避免MB瓶颈
  也许通过批量写入每个磁盘日志中的许多写入

5.2：忙时插入的时间
  大概是测量时间，直到客户端通过主MB和SU看到回复
  取决于主区域有多远
  当地主人：75.6毫秒
  主人附近：131.5毫秒
  主人其他海岸：315.5毫秒

为什么要75毫秒写入本地掌握的记录？
  光速延迟？
    不：本地
  排队等待其他客户的运营？
    不：他们意味着100个客户是最大的，没有造成延迟上升
  结束5.2建议在SU中40毫秒75毫秒
    怎么可能需要40毫秒？
      每个键/值是一个文件？
      创建文件需要3个磁盘写入（目录，索引节点，内容）？
    什么是其他35毫秒？
      MB磁盘写？

5.3 /图3：增加请求率的效果
  我们对图形w / x轴要求速率，y轴延迟有什么期望？
    对于较低的速率，恒定的延迟
    但系统有一些最大容量，由于磁盘寻找或CPU
    对于更高的费率，队列迅速增长，avg潜伏期爆炸
  爆炸应接近最大容量h / w
  我们在图3中看不到爆炸
    结束5.3表示客户太慢了
  文字说最高速度约为3000 /秒
    10％写，所以300写/秒
    每个区域5个SU，所以60个写/ SU /秒
    关于如果每次写入都是随机的磁盘I / O
    但是，您需要为数百万活跃用户提供大量SU

后退，什么是PNUTS的关键设计决策？
  1.复制多个地区的所有数据
     快速读取，缓慢但异步写入
  轻松的一致性 - 陈旧的读数
     需要快速读取和异步写入
  序列全部写入通过记录主机
     有一致性; 延迟不好 对容错可能不好
  4.订单只适用于个别记录
     简化系统; 也许应用程序很尴尬

纸张不清楚的地方
  写入期间的消息顺序是什么？
  每个记录的版本＃保持如何/在哪里？
  两部分版本＃意味着删除后会记住 - 哪里？
  如何订购相同密钥的删除和后续插入？
  Paper说write（）返回新版本＃ - 它是如何发现的？
  客户如何学习测试和写入的命运？
  什么选择写命令 - 主SU或主MB？
  写入和失败如何与更改记录的主人进行交互？

下一个： 
  测量Facebook的最终一致性
  然后是亚马逊的Dynamo，一个现实世界的DB甚至更松散的一致性