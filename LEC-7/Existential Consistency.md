## Existential Consistency

为什么我们读这篇文章？
  巨大的重读网站的存储（再次）
  一致性问题
  检测异常的技术

整体FB架构审查
  多个数据中心 - 地区
    用户网络延迟低，并行性可能容错
  每个地区都有很多前端（FE）
    Web服务器，网站逻辑，如Python或PHP
    排比
  每个区域都有一个完整的DB副本
    所以所有的读取都可以是本地的 - 用户经常看对方的数据
    为什么MySql：持久化，崩溃恢复，事务写入
  数据在每个区域的MySQL服务器上分片
    用于并行
  对于每个分片，一个区域是主人
    所以有一个最新的价值概念
    所有区域向主数据库发送写入
    主数据库更新其他区域的从站数据库
  每个区域都有很多缓存服务器
    缓存具有比读取数据高得多的吞吐量
      他们的工作量很重
    键/值对在缓存上分片
    FE读取第一个缓存，然后查看本地DB

不错的属性：
  使用现成的DB和（最初）缓存
  从更小的非复制非缓存系统逐渐增长

早期的FB“看起来”缓存有问题
  memcached缓存服务器（mc）
  由FE驱动; mc和DB不知道对方
  许多网站都是这样结构的！
  读（k）的
    v = mc-get（k）
    如果v = nil
      v =从本地DB获取
      mc-set（k，v）
    返回v
  写（k，v）
    发送k，v到主数据库
    MC-删除（k）的
    异步（写不等待）：
      主DB发送到从站DB
      所有数据库发送无效到缓存
        所以下一次从缓存中读取将会遗漏，从DB获取

FB很难看到旁边的缓存：
  *小姐/写作比赛
    read（）之间可能会发生整个写入（包括删除）
      DB提取和mc-set（）
    留下memcache与*永久*陈旧的数据
    用户最终会注意到缺少更新
  *写后异常
    C1在远程区域发送写入DB主机
    同一用户读取相同的密钥; 在memcache中错过; 从本地DB读取
      本地数据库没有看到更新
    用户可能马上注意到，看不到以前写的！
  *雷鸣的群体
    一个无效可能会导致许多FE同时错过该密钥
    并向数据库发送大量同时读取

造成这些问题的原因：
  任何实体都不知道 - 并排序 - 每个键上的并发操作

这些问题激发了新设计（TAO）以及愿望
  系统地监控正确性。

FB的新系统：TAO（图1）
  FE通过*缓存发送读/写*，而不是看起来
  将区域的FE拆分为多个叶缓存“群集”
    更多阅读并行性：每个键的多个缓存副本
  第二层“根”缓存
    每个区域每个分片一个根缓存
    所有写入和叶错误都通过区域的根缓存
    根高速缓存命令在每个键上写入+未命中 - 一次操作
  读：
    关键的碎片的叶缓存
    密钥分片的根缓存
    当地区域的密钥数据库
    作为回复返回，填充根/叶高速缓存 
  写：
    主区域中的叶，根，根，主区中的db和后面
      回复包含新值
      叶/根缓存在返回的路上更新
    异步：
      主数据库将日志复制到其他区域的从属数据库
      DB向缓存发送无效

TAO如何解决问题？
  *小姐/写作比赛：
    根缓存一次处理一个操作
    延迟写入直到读完成
    所以陈旧的读取回覆不会覆盖新的写入值
  *写后异常：
    缓存在从写入返回之前安装新值（从主数据库）
    写入完成之前，FE不会发出随后的读取
  *雷鸣：
    每个缓存每次只能转发一个未命中，其他的等待

TAO一致性模型
  纸说：
    缓存中的每个对象的顺序一致性
    缓存中的读写后一致性
    否则最终一致
  每个对象的顺序一致性是什么？
    每个对象的单个版本（写入）序列
    读取可能滞后 - 看到旧版本
    但客户永远不会倒退 - 永远不会看到新的，那么旧的
    接近PNUTS的时间线一致性
    也是最终一致性的一部分
      确保最后写入的协议
  什么是read-after-write？
    FE1写入
    那么FE2在相同的集群中读取
    FE2保证看到FE1的写（或稍后写）
    有助于确保人类用户看到他们的更改生效
    只要每个用户在同一个集群中使用FE
  什么是“缓存内”？
    仅当您查看单个缓存[cluster]时才保证
    如果你看不同的缓存/集群/区域，不保证
    因为不同的缓存可能具有较旧的版本

这是弱一致性
  读取可以产生陈旧的缓存数据
  对不同对象的写入可能会以不同的读取顺序出现

为什么我们想要更强的一致性？
  人类用户可能会抱怨陈旧或延迟的数据
    消息，股票报价，拍卖
  人类用户可能会抱怨订单异常
    如果在原始之前显示后续消息
  强烈的一致性可能会减少防御性编程的需要
    例如列表中的照片ID，但照片尚未存在
  强一致性可能会使仔细更新更容易
    PNUTS纸张的ACL与照片示例
    通过精心订购的写作 - 只有强大的一致性

为什么作者想要一致性检查器？
  他们的系统只保证弱一致性
  那是问题吗？还是基本可以吗
    它是否总是提供陈旧的数据？
    还是很少？
  他们使用线性化作为黄金标准
  他们也想要一个系统的方式来观看
    旧的看门人缓存有一些错误

什么是线性化？
  如果执行历史是线性化的
    可以找到所有操作的总顺序，
    匹配实时（对于非重叠操作），和
    其中每个读取都看到的值
    按顺序写入。

示例历史，x轴是实时的：
  | --Wx1-- | | -Wx2- |
     | ------ Rx2的------- |
              | -Rx1- |
  我们可以找到证明线性化的顺序吗？
    是：Wx1 Rx1 Wx2 Rx2
    服从实时规则
      Wx2，Rx2和Rx1并发，所以任何顺序与实时一致
    服从价值规则

他们如何检查线性化？
  选择一个（小）对象的随机子集（键）
  所有FE记录这些键上的所有读/写
  在一天结束时离线处理痕迹

跟踪条目中有什么？
  键，读写写，值哈希，开始时间，结束时间，＆c

本文为每个关键字的操作构建了一个图表
  图形边缘反映了排序约束
  在图中查找周期
  循环==总命令是不可能的

该文章谈到从一个图形开始读写节点，
  并将读取合并到写入中
  只需要考虑一个写入图就更简单了

构建写入图
  每个写入的图形节点
  两种有向图边缘：
    *时间：W' - > W“如果W'在W”开始之前完成
    *值：W' - > W“如果稍后读取看到写入的值
      W“完成之后
  两者意味着W“必须以W'的顺序排列

例：
  | --Wx1-- | | --Wx3-- |
     | --Wx2-- |
               | -Rx1- |
图有三个节点：Wx1，Wx2，Wx3
边：
  Wx1  - > Wx3（时间）
  Wx2  - > Wx3（时间）
  （Wx1 / Wx2没有时间边缘）
  Wx2  - > Wx1（Rx1看到的值）
没有循环; 总订单是：
  Wx2 Wx1 Rx1 Wx3
所以：操作历史可以线性化。

图4：
  WX1
       WX2
            RX1
  Wx1  - > Wx2（时间）
  Wx2  - > Wx1（值）
  循环 - >无总计 - >不可线性化
  “陈旧的异常” -  Rx1可能来自陈旧的缓存
    在其系统中合法，因为最终的一致性允许
    在线性化系统中不合法

图5
  WX1
        RX1
  WX2
        RX2
  Wx1  - > Wx2（值）
  Wx2  - > Wx1（值）
  “总订单异常”
  当并发写入时，任一结果都可以，但是
    随后的阅读必须同意！

这种技术会不会对非线性化的执行说“合法”吗？
  是的，如果不正确的FE时钟说，一个陈旧的阅读发生得比它早
    Wx1 Wx2
             RX1
    如果Rx1的时间不正确地表示它发生在Wx2之前，检查者会说“OK”

这种技术有可能对线性化执行说“非法”吗？
  是的，再一次FE时钟错了
    WX1
          RX1
                WX2
    但时钟表示Wx2发生在Rx1之前

为什么不能使用纸张的痕迹来检查因果一致性？
  （这是问题）
  这在因果一致性（x最初为0）时是合法的：
    C0：Wx1
    C1：Rx1
    C2：Rx0
  这是非法的：
    C0：Wx1
    C1：Rx1 Wy2
    C2：Ry2 Rx0
  也就是说，如果C2看到写入y，它也应该看到所有
    这可能导致了对y的写入。
  我们可以区分这些仅使用x跟踪，还是只跟踪？
  在第二个例子中，单独的y跟踪看起来就OK了
    Wy2 Ry2
    所以单单的追踪不足以发现非法处决
  对于合法和非法的追踪，x跟踪是相同的：
    Wx1 Rx1 Rx0
    所以单靠x跟踪不足以发现非法处决
  因为他们只追踪一小堆随机的密钥样本，
    他们不太可能看到x和y，所以他们不能
    检查因果一致性。

令人惊讶的是，本文的技术可以检查线性化
  毕竟，线性化约束对多个对象的操作
    就像因果一致
  并且多个对象部分使得因果一致性不可检查

为什么他们可以检查线性化
  假设轨迹只包含x，而不是y
  Wx1 Rx1 Rx0
  这可能是线性化的，不是
    取决于是否在Wx1完成后Rx0启动，实时
  它们的跟踪包含x上每个操作的开始/结束实时
  所以他们可以在Wx1完成后判断Rx0是否开始
  但这种技术确实取决于全球时钟协议
    该文件承认是一个问题 -  3.1节中的35毫秒

测量结果 - 表3
  我会期待许多线性化异常，从陈旧的高速缓存。
    因为TAO实现了一个轻松的一致性模型
  大的惊喜是有这么少！
    只有0.0004％的读数显示线性化异常
  为什么这么少的异常？
    很少写
    局部性（在写入缓存中一致性更好）
    快速无效信息

结果意味着什么？
  是0.0004％好还是坏？
    评论图片？
    在eBay拍卖中最新出价？
    密码更改？
  关于什么：
    确保后续的原始帖子后显示？
    为PNUTS删除妈妈从ACL，张贴图片？
    为广告印象计数？
  也许Facebook的主要目标是为用户提供新鲜度
    不是程序的语义
    用户可以忍受很多，所以0.0004％是相当不错的
    该文件对可编程性的影响没有太多的说明
  他们的结果如何泛化？
    与用户导向系统最相关，没有硬要求
    0.0004％取决于读取重，局部性和快速无效

结论
  低成本检查技术
  弱一致性设计可以提供非常高的一致性！
    即它们很少向用户显示过时的数据
    怀疑需要昂贵的一致设计
  一致性不总是一个正确的问题
    对于他们来说，关于用户显示的信息的新鲜度
    *不*关于正确/不正确或模块间合同
  结果是Facebook特定的
    但也许他们是许多网站的代表