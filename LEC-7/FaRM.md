## FaRM

为什么我们读这篇文章？
  很多人都想分散交易
  但是他们被认为是缓慢的
  本文建议不需要真实 - 非常令人惊讶的表现！

大的表现图片
  9000万*复制* *持久* *事务*每秒（图7）
    每台机器100万次/秒
    每个都有几个消息，用于复制和提交
    非常令人印象深刻
  一些其他系统每机器可以获得100万次操作/秒，例如memcached
    但不是交易+复制+持久（通常不是任何这些！）
  9000万视角
    每秒10,000个鸣叫
    每秒200万封电子邮件

他们如何获得高性能？
  数据必须适合总RAM（所以没有磁盘读取）
  非易失性RAM（所以没有磁盘写）
  单面RDMA（快速跨网络访问RAM）
  快速用户级别访问NIC
  事务+复制协议，利用单面RDMA

NVRAM
  FaRM写入RAM，而不是磁盘 - 消除了巨大的瓶颈
  可以在200 ns内写入RAM，但写入硬盘需要10 ms，SSD为100 us
    ns = nanosecond，ms = millisecond，us =微秒
  但RAM在电源故障中失去内容！本身不持久。
  为什么不写入f + 1机器的RAM，容忍f失败？
    如果故障始终是独立的，可能就足够了
    但电源故障不是独立的 - 可能会打100％的机器！
  所以：
    每个机架的电池，可以运行机器几分钟
    主电源故障时，电源h / w通知s / w
    s / w停止所有事务处理
    s / w将FaRM的RAM写入SSD; 可能需要几分钟
    然后机器关闭 
    在重新启动时，FaRM从SSD读取保存的内存映像
    “非易失性RAM”
  如果崩溃会阻止s / w写入SSD？
    例如FaRM或内核中的错误，或cpu / memory / hardware错误
    FaRM通过复制数据来处理单机故障
      从机器的副本的RAM到其他机器
      以确保始终为f + 1份
    崩溃（电源故障除外）必须独立！

为什么网络经常出现性能瓶颈？
  通常的设置：
    应用程式
    --- --- ---
    套接字缓冲区
    TCP TCP
    网卡驱动驱动
    NIC -------------------- NIC
  大量昂贵的CPU操作：
    系统调用
    复制邮件
    中断
    如果RPC都要两次
  慢：
    难以构建RPC可以提供超过几十万次/秒
    电线b / w（例如10吉比特/秒）很少是短RPC的限制
    这些每分组CPU成本是小消息的限制因素
  
FaRM的网络设置
  [主机，56 gbit网卡，昂贵的交换机]
  NIC做“单面RDMA”：内存读/写，而不是数据包传送
  发件人说“在这个地址写这个数据”，或者“读这个地址”
    NIC *硬件*在远端执行
    返回“硬件确认”
  没有中断，内核，复制，读（），＆c在远端
  一台服务器的吞吐量：1000万/秒（图2）
  延迟：5微秒（从他们的NSDI 2014纸）
  FaRM以三种方式使用RDMA：
    在事务执行期间单方面读取对象（也是VALIDATE）
    RPC由单面写入主日志或消息队列组成
    单面写入备份的日志

对NIC h / w的应用程序访问进行了简化
  应用程序直接与NIC交互 - 无系统调用，无内核
  发送方给NIC一个RDMA命令
  对于RPC，接收器s / w轮询RDMA写入的内存

大挑战：
  如何使用单面的读/写来进行事务和复制？
  我们看到的协议要求接收器CPU主动处理消息
    例如Raft和两阶段提交

我们来回顾分布式交易

记住这个例子：
  x和y是银行余额，也许在不同的服务器上
  T1：T2：
    add（x，1）tmp1 = get（x）
    add（y，-1）tmp2 = get（y）
                    打印tmp1，tmp2
  x和y从$ 10开始
  我们想要可序列化：
    结果应该好像交易按某种顺序一次运行一次
  只有两个订单是可能的
    T1然后T2产生11,9
    T2，T1产生10,10
    可序列化允许没有其他结果

如果T1完全在T2的两个get（）之间运行？
  如果交易协议允许，将打印10,9
  但不允许！
如果T2完全在T1的两个添加（）之间运行？
  如果交易协议允许，将打印11,10
  但不允许！

两类并发控制的交易：
  悲观：
    等待锁首先使用对象; 保持直到提交/中止
    称为两相锁定
    冲突造成延误
  乐观：
    访问对象没有锁定; 提交“验证”以查看是否可以
      有效：做写
      无效：中止
    称为乐观并发控制（OCC）

FaRM使用OCC
  原因：OCC让FaRM使用单面RDMA读取
    由于OCC，存储对象的服务器不需要设置锁定
  FaRM如何验证？我们将在稍后再看图4。

每个FaRM服务器都运行应用程序事务并存储对象
  一个应用程序事务是它自己的事务协调器（TC）

FaRM事务API（简化）：
  txCreate（）
  o = txRead（oid） -  RDMA
  的+ = 1
  txWrite（oid，o） - 纯粹是本地的
  ok = txCommit（） - 图4

有什么东西？
  <region＃，address>
  region＃将映射索引到[primary，backup1 ...]
  目标网卡可以直接使用地址来读或写RAM
    所以目标CPU不必涉及

服务器内存布局
  区域，每个对象数组
  对象布局
    标题与版本＃和锁
  为每个其他服务器
    （由RDMA编写，通过轮询阅读）
    传入日志
    传入消息队列
  所有这些都在非易失性RAM中（即在掉电时写入SSD）

每个区域复制一个主要的f备份f + 1副本
  [几个区域的图表，主要/备份]
  只有主要服务阅读; 所有f + 1看到提交+写
  如果<= f失败，则复制产生可用性
    即使只有一个副本保持活着; 比筏子好

txRead
  单面RDMA从主内存直接提取对象 - 快速！
  还提取对象的版本号，以检测并发写入

txWrite
  必须在txRead之前
  只写本地副本; 没有沟通

事务执行/提交协议w / o失败 - 图4
  我们一个接一个地考虑图4中的步骤
  思考并发控制现在（不复制）

LOCK（提交协议中的第一条消息）
  TC发送到每个写入对象的主要对象
  TC使用RDMA附加到每个主要的日志
  LOCK记录包含oid，version＃xaction read，new value
  主要s / w轮询日志，看到LOCK，验证，发送“是”或“否”回复消息
  注意LOCK都记录在主要的NVRAM *和* RPC交换中

主CPU在收到LOCK时做什么？
  （对于每个对象）
  如果对象锁定，或版本！=什么xaction读取，回复“否”
  否则设置锁定标志并返回“是”
  注意：*如果对象已被锁定，则不会阻塞

TC等待所有LOCK回复消息
  如果有“否”，中止
    发送ABORT到初级，以便他们可以释放锁
    从txCommit（）返回“否”

现在我们忽略VALIDATE和COMMIT BACKUP

TC将COMMIT-PRIMARY发送到每个写入对象的主要对象
  使用RDMA附加到主日志
  TC只等待硬件ack  - 不等待主要处理日志条目
  TC从txCommit（）返回“yes”

当它在日志中处理COMMIT-PRIMARY时，主要做什么？
  复制对象内存的新值
  增量对象的版本＃
  清除对象的锁定标志

例：
  T1和T2都要增加x
  都说
    tmp = txRead（x）
    tmp + = 1
    txWrite（x）的
    ok = txCommit（）
  x应该以0，1或2结尾，与成功承诺的成功程度一致

如果T1和T2正好在步骤呢？
  T1：Rx0 Lx Cx
  T2：Rx0 Lx Cx
  会发生什么？

要么
  T1：Rx0 Lx Cx
  T2：Rx0 Lx Cx

要么
  T1：Rx0 Lx Cx
  T2：Rx0 Lx Cx

直觉为什么验证检查可序列性：
  即检查“一次执行一次？”
  如果没有冲突，版本不会更改，并且允许提交
  如果有冲突，会看到锁或更改版本＃

图4中的VALIDATE怎么样？
  它是对刚刚被事务读取的对象的优化
  VALIDATE =单面RDMA读取以获取对象的版本号和锁定标志
  如果锁定设置或版本＃自读取以来更改，TC将中止
  不设置锁定，因此比LOCK + COMMIT快

VALIDATE示例：
x和y最初为零
T1：
  如果x == 0：
    y = 1
T2：
  如果y == 0：
    x = 1
（这是一致性的经典测试示例）
T1，T2产生y = 1，x = 0
T2，T1产生x = 1，y = 0
中止可以离开x = 0，y = 0
但是序列化禁止x = 1，y = 1

假设同时：
  T1：Rx Ly Vx Cy
  T2：Ry Lx Vy Cx
  LOCK将会成功
  由于锁定位都被设置，VALIDATE将都会失败
  所以都会中止 - 这是可以的

怎么样：
  T1：Rx Ly Vx Cy
  T2：Ry Lx Vy Cx
  然后T1提交，T2仍然中止，因为T2的Vy看到T1的锁或更高的版本
但是我们不能在两个*之前都有* V
所以VALIDATE在这个例子中似乎是正确的
  并且快：快于LOCK，不需要COMMIT

容错度怎么样？
  防范丢失数据？
    耐用？可用？
  诚实的进行交易，尽管崩溃？
  分区？

高级复制图
  oo地区1
  oo地区2
  o CM
  ooo ZK

每个区域的f + 1个拷贝可容忍每个区域的<= f个故障
  TC将所有副本发送到所有副本（TC的COMMIT-BACKUP）
  如果服务器崩溃，则不能立即使用
    交易读取和提交将等待
  但CM很快就会注意到，新的副本，恢复交易

重构
  一个ZooKeeper集群（少数副本）
    存储配置＃，此配置中的服务器集，以及CM
    如果多个服务器尝试成为CM，则断开连接
    如果分区，请选择活动分区
  配置管理器（CM）（未复制）
    通过快速ping监视所有服务器的活动
    管理重新配置
      检查每个区域的至少一个副本是否存在
      将区域分配给主/备份集
      告诉服务器复制新的副本
      管理中断交易的完成

让我们回头看看图4提交协议，看看怎么样
  尽管服务器出现故障，但可能已经提交的任何xaction都将可见。
  “可能已经承诺”：
    TC可能已经向客户答复了“是”
    主要可能已经显示了对后续读取的更新

在TC从所有LOCK和VALIDATE看到“是”之后，
  TC将COMMIT-BACKUP附加到每个备份的日志中
  毕竟，追加COMMIT-PRIMARY到每个小学的日志
  之后，报告“提交”申请

注意TC复制到备份; 初选不复制
  COMMIT-BACKUP包含书面值，足以更新备份状态

为什么TC只有在* all * COMMIT-BACKUPs的acks之后才发送COMMIT-PRIMARY？
  一旦初始化可以看到COMMIT-PRIMARY就可以执行
    并显示其他交易的更新
  所以到目前为止，每个对象的新值必须在f + 1个日志（每个区域）
    所以f可以失败而不失去新的价值
  如果还有一个没有COMMIT-BACKUP的备份
    该对象的写入仅在f日志中
    所有f可能与TC失败
    那么我们会有暴露的提交，但也许永远丢失一个写！

为什么TC等待COMMIT-PRIMARY的确认？
  以便有一个完整的f + 1区域知道提交
  在此之前，每个区域只有f个备份知道（来自COMMIT-BACKUPs）
  但是我们假设每个地区的f失败

为什么恢复可能的基本推理原则：
  如果TC可以报告“提交”，或者主要可能具有暴露价值，
  那么每个区域的所有f + 1在日志中都有LOCK或COMMIT-BACKUP，
  所以f可以从任何/每个区域失败，而不会丢失写入。
  如果恢复看到一个或多个COMMIT- *和COMMIT- *或LOCK
    从每个地区，它承诺; 否则中止。
    即证据TC决定提交，加上每个对象的写入。
    （第5.3节，步骤7）

FaRM非常令人印象深刻; 它不完美吗？
  *由于OCC，因为很少的冲突，效果最佳。
  *数据必须符合总RAM。
  数据模型是低级别的; 将需要例如SQL库。
  *细节由特定NIC功能驱动; 如果网卡有测试和设置？

概要
  分布式交易被认为太慢以至于被严重使用
  FaRM可能表明不一定是真的