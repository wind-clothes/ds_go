##

> R *仍然以原始形式使用，或者只是更多的灵感
>未来系统？


R *是实验研究体系; 我怀疑它从未被使用过
商业。然而，它和系统（System R）是
非常有影响力 许多后续的商业系统借用了它们
想法。


>什么样的当前系统使用2PC或推定中止/提交


许多现代数据库支持分发数据
许多服务器实现并行加速，从而能够支持
高负载 这些数据库使用2PC来实现使用的事务
多个分片上的记录。如果您在网上搜索“oracle推测”
中止“或”ibm推定中止“，您将看到提示他们的商业DB
产品使用PA。


鉴于本文于1986年出版，有关系统
>是过时的 是否有较新的系统拥抱死锁
>数据库？


支持交易的每个数据库系统都必须应付
deaadlocks。问题和可能的解决方案设计没有
真的从R *改变了。如果你在网路上捅了，你会发现很多
关于IBM DB2等现代数据库中的死锁的材料。


>我的问题更多是一个元问题。我想知道为什么我们似乎
>已经及时回顾研究这个旧系统？好像我们有
已经趋向于了解越来越多的新事物。


今天发明的想法很久以来就被发明了
前。至少30年前发明了两阶段的承诺，但仍然是
在当今的分布式系统中很重要。

通常我们分配一张旧纸的原因是我们想谈谈
一个重要的想法是旧的，没有新的论文做得很好
描述这个想法的工作。通常新的论文假设读者已经有了
了解老想法


看到一个早期版本是有趣的
>分布式事务系统？


我觉得很有趣的是阅读关于这样的主题的旧论文
当作者没有提出假设时，他们可能会令人困惑
几十年后难以重建。


为什么这么重要的交易是原子的？


什么“事务”是指事务中的步骤发生
关于故障和其他交易原则上。原子在这里
意思是“全或无”。交易是一些存储提供的功能
使编程更容易的系统。这种的一个例子
交易有帮助的情况是银行转账。如果银行
想要将100美元从爱丽丝的帐户转移到鲍勃的账户，
如果在这个中途的一个碰撞，爱丽丝扣除了，这将是非常尴尬的
$ 100，但Bob *不*以100美元计算。所以（如果您的存储系统支持
交易）程序员可以写出类似的东西

开始交易
  减少爱丽丝的余额100;
  增加鲍勃的余额100;
终止交易

交易系统将确保交易是原子的;
无论是发生还是不发生，即使有崩溃。


>这种共识算法的优点在一个以上
>使用多数协议？


分布式原子提交导致不同的计算机做*不同*
事情（例如爱丽丝的银行借记爱丽丝，鲍勃的银行贷款鲍勃）和我们
想要他们*所有*做他们的事情，或没有一个。原子提交
系统通常不会面对故障，因为它们
要求所有参与计算机执行其部分
交易。

共识（例如Raft）会导致一组计算机（副本）
*相同*的东西（所以他们仍然是副本）。此外，我们愿意解决
只有大多数，因为我们希望系统可用
面对失败。

您应该查看两阶段提交和筏作为解决不同的问题。


>这样一个系统应该有多少个下属才可靠
>有效吗


下属的数量由数据库的数据确定
在服务器之间分配，以及给定事务的数据记录数量
使用。

如果负载很高，或数据量非常大，那么
数据库需要在可执行的许多服务器之间进行分片
平行。一个非常大的数据库可能会将数据分解成数十或数十个
数百台服务器。

给定交易涉及的下属数量由...设定
事务使用记录的碎片数。如果一个
事务只查看两个数据库记录，那么最多只有
交易将使用两个下属。如果交易使用数千
的数据库记录，可以将所有服务器作为下属。

在这里使用多个服务器的要点不是增加
可用性。它是通过并行执行实现更高的吞吐量。


>本文反复提到“忘记”犯下和中止
>消息。它总是使用这个术语在引号中，我并不完全确定
这是什么意思 这只是意味着删除任何待处理状态
>交易有（在恢复期间会很重要）？
>
>在上下文中：“强制写入提交记录，发送确认
>（ACK）消息给协调器，然后提交事务和
>“忘记”它。


本文使用“忘记”来表示删除交易的所有记录
（尽管对DB执行的任何写入仍然保留）。因此，如果
技术委员会已经忘记了一个交易，而下属则询问
该交易，TC将不会有任何交易记录; 许多
的论文是关于如何在这种情况下正确进行的。
忘记是重要的，因为否则TC和下属会
必须记住每一笔交易，这在几年后会变得尴尬
的经营和数百万笔交易。


>我的问题：恢复过程在哪里生活？有一个
>服务器 如果没有，消息如何发送到此恢复过程？


每个服务器都有单独的恢复过程。


>对于2PC，是恢复过程始终在（虚拟存储）
>始终保持更新的稳定存储）？如果只开始
>在失败时读取日志，是否有效？


服务器的恢复过程仅在出现问题时运行（超时）
或崩溃+重启）。恢复可能很慢，因为它可能需要读取状态
从磁盘日志，或发送查询到其他服务器。但希望是
恢复只需要很少运行。


>另一个问题：一些服务器如何说交易是
>只读和其他没有？


每个下级执行交易的不同部分; 一些
部分可能仅涉及读取，其他可能涉及写入。对于
例如，交易可能如下所示：

开始交易
  如果6.824的学生少于6.830，
    招收学生6.824
  其他：
    招收学生6.830
终止交易

假设6.824信息存储在一个服务器上，而6.830
信息在另一个。如果“if”为真，则事务读取
6.830信息但不写。因此，部分
在6.830的服务器上完成的事务是只读的。但是部分做了
6.824的服务器是读/写。


>什么类型的系统使用分层2阶段提交描述
>论文？


我怀疑是为了应对SQL语句（或查询计划）
涉及到子查询。例如，假设表ttt是分片的
跨越许多服务器。如果程序说

  开始交易
    UPDATE ttt SET x =（SELECT ...）
  终止交易

然后每个服务器的工作份额都要求它运行内部的SELECTs
计算每行的新列x值。那些SELECT可能需要
被发送到其他服务器，那些其他服务器将需要获取
锁定，当TC决定是否提交时，贡献是或否
在最后的COMMIT或ABORT之后释放锁。自然
这是一个层次结构。

两个表的连接也可以要求每个服务器从中收集数据
其他服务器，因此可能是层次结构的天然适合
交易。


>问：为什么下属会向协调者发一个NO VOTE
>正常运行？

这是一个很好的问题！我们最关心的是如果
下属坠毁并重新启动后，为此做了一些工作
交易之前收到准备信息; 在崩溃期间
它将失去其暂时更新的记录，并锁定它
收购，所以不能完成交易，必须投票。
另一个可能性（取决于数据库的工作原理）是如果
下级检测到对数据的违规约束（例如，
事务试图用表中的重复键写入记录
需要唯一的键）。下属的另一个可能性是
陷入僵局，必须中止打破僵局。

使原子提交更快的一种方法是限制事务
在某些或所有情况下，下属不能说NO。只读
论文第3节中的交易是这样的。这张纸
识别更多这样精简的情况：

https://www.usenix.org/system/files/conference/atc12/atc12-final118.pdf


有没有任何情况，你不想使用推定中止
>最初提出的协议？


我认为推定中止与交易之间的2P不同
部分或全部只读，在这种情况下，PA似乎更加严格
高效。所以我不认为你会喜欢2P的情况
到PA。


谁在分配中扮演协调者的角色
>交易？客户端，第三方“仲裁者”还是别人？是
>这可能会让仲裁者发出提交
>请求并回复客户？


有两个常见的安排。一种可能性是服务器行为
作为TC（交易协调员）; 它特别方便
参与交易的服务器之一也是TC，
因为它保存了一些消息。另一个常见的设置是客户端
也可以作为TC，再次保存一些消息，虽然这可能很棘手
以确保作为TC的客户端具有所需的崩溃恢复
属性。


>在2.2节中，本文讨论了从属故障和恢复
>进程，但不是协调器。


第2.2节的“恢复过程”运行在TC和
下属。例如，2.2中的文本“如果恢复过程
在提交状态中查找交易...“，适用于TC
（如果TC从所有下属获得了YES票，记录提交记录，
然后坠毁）。

这篇文章的文字很混乱，因为它是用一般的方式写的
足够应用于服务器的层次结构（根TC，非叶
下属部分担任TC，叶下属）。


>此外，它不讨论下属尝试时会发生什么
>在恢复期间联系协调器，协调器失败。


如果下属需要联系TC，则下属必须保留
尝试直到TC回答。


>如何恢复过程无法区分角色（协调器
>与下属）根据查询？


我认为纸张的情况是一个服务器
完全忘记了交易。在分级
交易方案，层次结构中间的服务器同时作为两者
协调员（为他们的下属）和下属（到）
协调员）。所以可能不清楚哪个能力
正在查询健忘的服务器。


>协调者在重新启动时如何终止事务呢？
>通知任何下属（第2.2节，最后一段）？


我认为这篇文章是指“TC在交易过程中忘记了这一点
崩溃，因为它丢失了RAM的内容。“TC没有做任何事情
积极地中止交易（因为它不再甚至知道
交易存在），但会回复ABORT任何有关的查询
交易。



>我找不到任何提及如果ACK消息会发生什么
>下属和协调员之间的运输失去了。是吗
>在某个时候从属重试？协调员是否重试发送
>下属在某点？


我相信TC重新发送COMMIT消息，直到下属
答案。TC需要确保下属听到（并记录）
TC之前的COMMIT可以忘记交易。


>两阶段提交文件不提及复制数据
个人下属，使下属的失败可以
受到分布式数据库系统的保护，没有投票没有
>每笔交易。2PC如何在系统之上工作
>下属运行Raft / Paxos，以提高稳定性
> 2PC协议中的下属？


你是对的，2PC不提供可用性，因为有
它必须阻止等待崩溃的服务器重新启动的情况。
如果您希望继续执行任何单一故障，则必须打开2PC
顶部的复制方案如Raft或Paxos，使TC和每个
下属被复制。TC和下属必须实施
一种与筏/ Paxos兼容的方式，原则上很容易
（您将在实验3中看到）需要遵循一些规则。你会得到一个
在实验4中有一点经验，那里有一个专门的
两阶段提交类协议涉及移动密钥/值的碎片
从一个复制组到另一个复制组。


在讨论死锁检测器时，作者说
因为他们不希望死锁发生频繁，他们对待
>每个检测到的僵局都是一个真正的僵局。这是一个公平的假设
（在现实中，死锁发生的频率是多少），有没有
潜在的危害假阳性检测到僵局？


我的经验是，僵局是罕见的。此外，我怀疑，如果
有人有他们频繁的工作量，他们可能会
重写他们的交易以减少死锁（也许是
在每个交易中以相同的顺序获取锁）。的危险
错误的是，交易将不必要地中止和拥有
被重新执行，浪费时间。


>此外，该文件提到“受害者交易中止”。如果僵局
>不要偶尔发生，这不是对可靠性的重大打击吗？


通常，如果客户端软件重新执行该事务
中止。


>考虑演讲笔记中的修改示例：
>
> x和y是银行余额
> x和y从$ 10开始
> T1正在从x向y转移$ 1
> T1：
> add（x，1） - 服务器A
> add（y，-1） - 服务器B
> T2：
> tmp2 = get（y）
> tmp1 = get（x）
>打印tmp1，tmp2
>
>修改部分是T2中的前两条指令
换掉了 在第一个两阶段提交期间可能有T1
>收到x和T2的锁，收到y的锁，在期间
>第二次两阶段提交，T1获得了y和T2的锁定
>锁定x，最终T2输出11，10？


这个例子会死锁。由于锁x和y已被保持，T1和
T2都会永远等到他们的第二线。在R *，最终
死锁检测器将中止一个或另一个。


>如果下属在写入之前发送ACK，会发生什么
> COMMIT记录？


这不会发生，因为R *在发送之前写入COMMIT记录
ACK。

假设可能会发生，下属在发送后崩溃
ACK和写入COMMIT之前。TC将接收到ACK和
忘记交易。重启后，下属会看到
PREPARE记录在其日志但不是COMMIT记录，它会问
TC是否提交交易。按照论文的规定
2P，TC将回复ABORT，因为TC没有记录
交易。这是一个严重的错误，因为事务实际上
承诺。


>实际的DB修改/读取实际上如何适应？
>基本上，我想知道以下两个下属是哪个
做：1）在PREPARE中写入日志的力量，他们写一个
> REDO日志操作的数量，描述交易的操作
>应该接受COMMIT信号，然后应用它们
>操作，并强制用各种方式写入COMMIT操作
> UNDO日志操作（或者也可能没有新的撤消/重做日志条目）和ACK
> 2）在强制将PREPARE写入日志之前，应用它们
>在交易中进行操作，然后用UNDO强制写一个PREPARE
>日志条目，然后将YES发送回协调器。收到后
>一个提交条目，他们写上面的COMMIT操作。
或者也许他们正在做别的事情 我很困惑
>关于他们的一些实施细节。


在下载之后，下级应用更新
COMMIT到它的日志。


>如果下属写一个COMMIT，然后崩溃会发生什么
>发送确认ACK？什么妨碍协调员
不得不等待永远的认可？


TC将继续重新发送COMMIT，直到下属重新启动
用ACK响应。如果下属从不重启，TC必须
等待永远

两阶段提交的目标不是确保连续可用性
即使有些服务器关闭; 相反，它假定所有服务器将会
最终活着，并确保（一旦他们活着）他们全部
达成同样的承诺和中止决定。

如果你想要高可用性和原子提交，你可以层
在Raft复制服务之上进行两阶段提交（即使用Raft to
复制TC和每个下属）。


他们似乎把强制写作当作原子，但如果有的话会发生什么
在强制写作中的崩溃？为什么他们可以假设呢
这些操作是原子的？


磁盘写入可能不是原子的，例如，如果您踢机械的
在写作时开车。然后写入的部门可能会最终出现
混合了旧数据和新数据。如果读取该磁盘将会检测到此问题
该部门，因为每个部门的校验和将失败。

两相提交软件可以通过检查来处理磁盘写入错误
写入完成正确（磁盘告诉它，或者
软件从磁盘读取数据）。如果写完成，
下级可以响应PREPARE或COMMIT消息。如果写
没有完成，软件应该重新尝试写。


>协调员失败时会发生什么？系统会
>变得不可用


是的：在协议中有点，如果一个TC或从属
失败，其他服务器必须等待（也许很长一段时间）
服务器重启失败。


为了本文的目的，实施了R *的哪些硬件？

我不知道！可能是IBM大型机硬件从20世纪80年代。