## RPC和线程

最常见的问题：为什么选择GoLang？

1. 6.824用于使用C++

	学生花时间修复与分布式系统无关的错误,例如：他们释放了仍在使用的对象

2. Go允许您专注于分布式系统问题

    良好的并发支持;
    很好的支持RPC;
    垃圾收集（解除后不使用）;
    类型安全.

一门非常容易学习的语言，可以使用教程[effective_go](https://golang.org/doc/effective_go.html)

[https://golang.org/pkg/net/rpc/](https://golang.org/pkg/net/rpc/)

Go中的线程是一个有用的结构化工具，Go叫他们goroutines，也有人称其为线程。

1. 为什么线程
由于进程资源的成本是相当昂贵的，而且使用多线程的话，可以提供系统的并行性，可以处理更多的操作。

	I / O的多路复用：在等待来自其他服务器的响应时，处理下一个请求

	多核：线程在多个内核并行运行

2. Thread等于“执行线程”
线程允许一个程序（逻辑地）一次执行许多事情，线程共享内存，每个线程包括一些每线程状态：**程序计数器，寄存器，堆栈**

3. 程序中有多少个线程？
系统的线程数量取决于系统的硬件和系统的业务需求，不是越多越好，因为存在线程的切换带来的性能损耗，另外线程是占据系统资源的。
	
	通常比内核更多的线程

	Go语言可以在运行时在可用内核上协调线程
    
4. 线程挑战：
  * 共享数据 
     一个线程读取另一个线程正在更改的数据？
     可能导致临界条件，解决方法就是不共享或协调共享（例如，互斥）
  * 线程之间的协调
    例如等待所有Map线程完成
    可能导致死锁（通常比竞赛更容易注意）解决方法是使用Go channel或WaitGroup
  * 并发性的粒度
     粗粒度 - >简单，但并发/并行性很小
     细粒度 - >更多的并发性，更多的锁和同步
  
演习：两个挑战

1. 使用I / O并发

    在提取网址时，可以使用另一个网址
2. 获取每个URL

    必须避免浪费网络带宽

    希望对远程服务器很好

    =>需要一些跟踪哪些URL访问的方式 
    
解决方案[see handouts：crawler.go]

1. 首先：将获取的Map传递给递归调用

    当抓取需要很长时间时，I / O不会重叠

    不利用多个内核
2. 解决方案与go协程和共享获取的Map

    为什么锁？（删除它们，每一个似乎都有效！）没有锁可能会发生什么问题？检查和标记url不是原子的。

    所以可能会发生两次获取相同的URL。
      T1检查抓取[url]，T2检查抓取[url]，两者都看到该url尚未被抓取，两者都返回false和两次提取，这是错误的，这称为*内存一致性问题*，该bug是在多个线程对共享内存进行读写的时候发生。

    这种现象是很难发现很难从表面去理解其原因的，我们可以通过crawler程序检测竞争（go run-race crawler.go）请注意，访问的检查和标记必须是原子的。

    我们如何能够决定我们是否处理一个页面？waitGroup
3. channels解决方案

    channels：一般闭包机制来协调线程
      消息的有界缓冲区
      几个线程可以在channel上发送和接收
        （Go运行时内部使用锁）

    发送或接收可以阻止
      当channels已满时
      当channels为空时

    通过主线程调度每个url提取
      没有竞争获取Map，因为它不共享！

4. 什么是最好的解决方案？

	所有并发的数据比串行数据更加困难

	有些Go设计师认为避免共享内存:即只使用channels，既通过通信来共享内存
    
	我的实验中的解决方案使用许多并发功能
    	锁定时共享是自然的
        例如，几个服务器线程共享Map
    
	线程之间的协调通道
      例如，生产者/消费者风格的并发
  使用Go的竞争检测器：
    https://golang.org/doc/articles/race_detector.html

5. 远程过程调用（RPC）

	分布式系统的关键部分; 所有实验都使用RPC
	
	目标：易于编程的网络通信
    
	隐藏客户端/服务器通信的大部分细节
	
	客户端调用很像普通程序调用
	
	服务器处理程序很像普通程序
	
	RPC被广泛使用！

6. RPC理想地使净通信看起来像fn调用：

	```
  客户：
    z = fn（x，y）
  服务器：
    fn（x，y）{
      计算
      返回z
    }
  RPC旨在实现这种透明度
	```
例如：kv.go [见讲义：kv.go]

	客户端“调用”服务器并调用Call（）
      调用类似于常规函数调用

    服务器在单独的线程中处理每个请求
      并发！因此，锁定键值。

RPC消息图：

```
  Client             Server
    request--->
       <---response
```
软件结构

```
  client app         handlers
    stubs           dispatcher
   RPC lib           RPC lib
     net  ------------ net
```
7. 几个细节：

###### 一些细节：
+ 应该调用哪个服务器函数（handler）？
+ 序列化：格式化数据到包中
     + 棘手的数组，指针，对象等。
     + Go的RPC库非常强大。
     + 有些东西你不能传递：比如channels和function。
+ 绑定：客户端怎么知道应该跟谁通信？
   + 也许客户端使用服务器的hostname。
   + 也许使用命名服务，讲服务名字映射到最好的服务器。
+ 线程：
  + 客户端可能使用多线程，所以多于一个调用没有被处理，对应的处理器可能会是否缓慢，所以
    服务器经常将每个请求放置在独立的线程中处理。

###### RPC问题:怎么处理失败？
+ 比如：丢包，网络断线，服务器运行缓慢，服务器崩溃。

###### 错误对RPC客户端意味着什么?
+ 客户端没有获取到服务器的回复。
+ 客户端不知道服务器是否接收到请求！也许服务器的网络在发生请求前就失败了。

###### 简单的方案：“最少一次”行为
+ RPC库等待回复一段时间，如果还是没有回复到达，重新发生请求。重复多次，如果还是没有回复，那么返回错误给应用程序。

###### Q: "至少一次"容易被应用程序处理吗？
+ 至少一次写的简单问题：
  客户端发送"deduct $10 from bank account"

###### Q: 这个客户端程序会出现什么错误？
+ Put("k",10) -- 一个RPC调用在数据库服务器中设置键值对。
+ Put("k",20) -- 客户端对同一个键设置其他值。


###### Q: 至少一次每次都可以很好的工作吗？
+ 是的：如果回复操作的是OK,比如，只读操作。
+ 是的：如果应该程序有自己处理多个写副本的计划。

###### 更好的RPC行为：“最多一次”
+ idea:服务器的RPC代码发现重复的请求，返回之前的回复，而不是重写运行。
+ Q：如何发现相同的请求?
  client让每一个请求带有唯一标示码XID(unique ID),相同请求使用相同的XID重新发送。
    server：
      if seen[xid]:
          r = old[xid]
      else
          r = handler()
          old[xid] = r
          seen[xid] = true


8. 一些关于“最多一次”的复杂性
这些都会断断续续地出现在实验二中
+ 怎么确认xid是唯一的？
  + 很大的随机数?
    + 将唯一的客户端ID（ip address？）和序列号组合起来？
+ 服务器最后必须丢弃老的RPC信息？
  + 什么时候丢弃是安全的？
  + idea：
    + 唯一的客户端id
        + 上一个rpc请求的序列号
        + 客户端的每一个RPC请求包含"seen all replies <=X" 
        + 类似tcp中的seq和ack
    + 或者每次只允许一个RPC调用，到达的是seq+1，那么忽略其他小于seq
    + 客户端最多可以尝试5次，服务器会忽略大于5次的请求。
+ 当原来的请求还在执行，怎么样处理相同seq的请求？
  + 服务器不想运行两次，也不想回复。
  + 想法：给每个执行的RPC，pending标识；等待或者忽略。

###### 如果“至多一次”服务器奔溃或者重启会怎么样？
+ 如果服务器将副本信息保存在内存中，服务器会忘记请求，同时在重启之后接受相同的请求。
+ 也许，你应该将副本信息保存到磁盘？
+ 也许，副本服务器应该保存副本信息？

###### 关于“至少执行一次”？
+ 至多一次+无限重试+容错服务

###### Go RPC实现的”最多一次“？
+ 打开TCP连接
+ 向TCP连接写入请求
+ TCP也许会重传，但是服务器的TCP协议栈会过滤重复的信息
+ 在Go代码里面不会有重试（即：不会创建第二个TCP连接）
+ Go RPC代码当没有获取到回复之后将返回错误
  + 也许是TCP连接的超时
  + 也许是服务器没有看到请求
  + 也许服务器处理了请求，但是在返回回复之前服务器的网络故障
