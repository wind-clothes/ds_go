## RPC和线程

最常见的问题：为什么选择GoLang？

1. 6.824用于使用C++

	学生花时间修复与分布式系统无关的错误,例如：他们释放了仍在使用的对象

2. Go允许您专注于分布式系统问题

    良好的并发支持;
    很好的支持RPC;
    垃圾收集（解除后不使用）;
    类型安全.
3. 我们喜欢Go中的编程
	
	简单的语言学习。

Go学习：https://tour.go-zh.org/list

Go中的线程是一个有用的结构化工具，Go叫他们goroutines，也有人称其为线程。

1. 为什么线程
由于进程资源的成本是相当昂贵的，而且使用多线程的话，可以提供系统的并行性，可以处理更多的操作。

	I / O的多路复用：在等待来自其他服务器的响应时，处理下一个请求

	多核：线程在多个内核并行运行

2. Thread等于“执行线程”
线程允许一个程序（逻辑地）一次执行许多事情，线程共享内存，每个线程包括一些每线程状态：**程序计数器，寄存器，堆栈**

3. 程序中有多少个线程？
系统的线程数量取决于系统的硬件和系统的业务需求，不是越多越好，因为存在线程的切换带来的性能损耗，另外线程是占据系统资源的。
	
	通常比内核更多的线程

	Go语言可以在运行时在可用内核上协调线程
    
4. 线程挑战：
  * 共享数据 
     一个线程读取另一个线程正在更改的数据？
     可能导致临界条件，解决方法就是不共享或协调共享（例如，互斥）
  * 线程之间的协调
    例如等待所有Map线程完成
    可能导致死锁（通常比竞赛更容易注意）解决方法是使用Go频道或WaitGroup
  * 并发性的粒度
     粗粒度 - >简单，但并发/并行性很小
     细粒度 - >更多的并发性，更多的锁和同步
  
演习：两个挑战

1. 使用I / O并发

    在提取网址时，可以使用另一个网址
2. 获取每个URL

    必须避免浪费网络带宽

    希望对远程服务器很好

    =>需要一些跟踪哪些URL访问的方式 
    
解决方案[see handouts：crawler.go]

1. 首先：将获取的地图传递给递归调用

    当抓取需要很长时间时，I / O不会重叠

    不利用多个内核
2. 解决方案与go协程和共享获取的地图

    为什么锁？（删除它们，每一个似乎都有效！）没有锁可能会发生什么问题？检查和标记url不是原子的。

    所以可能会发生两次获取相同的URL。
      T1检查抓取[url]，T2检查抓取[url]，两者都看到该url尚未被抓取，两者都返回false和两次提取，这是错误的，这称为*内存一致性问题*，该bug是在多个线程对共享内存进行读写的时候发生。

    这种现象是很难发现很难从表面去理解其原因的，我们可以通过crawler程序检测竞争（go run -race crawler.go）请注意，访问的检查和标记必须是原子的

    我们如何能够决定我们是否处理一个页面？waitGroup
3. channels解决方案

    channels：一般钱包机制来协调线程
      消息的有界缓冲区
      几个线程可以在频道上发送和接收
        （Go运行时内部使用锁）

    发送或接收可以阻止
      当channels已满时
      当channels为空时

    通过主线程调度每个url提取
      没有竞争获取地图，因为它不共享！

4. 什么是最好的解决方案？

	所有并发的数据比串行数据更加困难

	有些Go设计师认为避免共享内存:即只使用channels，既通过通信来共享内存
    
	我的实验中的解决方案使用许多并发功能
    	锁定时共享是自然的
        例如，几个服务器线程共享地图
    
	线程之间的协调通道
      例如，生产者/消费者风格的并发
  使用Go的竞争检测器：
    https://golang.org/doc/articles/race_detector.html
    去测试-race mypkg

5. 远程过程调用（RPC）

	分布式系统的关键部分; 所有实验都使用RPC
	
	目标：易于编程的网络通信
    
	隐藏客户端/服务器通信的大部分细节
	
	客户端调用很像普通程序调用
	
	服务器处理程序很像普通程序
	
	RPC被广泛使用！

6. RPC理想地使净通信看起来像fn调用：

	```
  客户：
    z = fn（x，y）
  服务器：
    fn（x，y）{
      计算
      返回z
    }
  RPC旨在实现这种透明度
	```
例如：kv.go [见讲义：kv.go]

	客户端“调用”服务器并调用Call（）
      调用类似于常规函数调用

    服务器在单独的线程中处理每个请求
      并发！因此，锁定键值。

RPC消息图：

```
  Client             Server
    request--->
       <---response
```
软件结构

```
  client app         handlers
    stubs           dispatcher
   RPC lib           RPC lib
     net  ------------ net
```
7. 几个细节：

	哪个服务器功能（处理程序）调用？
    在Go中指定的Go（）
	
	编组：将数据格式化成数据包
    针对数组，指针，对象和c
    Go的RPC库非常强大！
    有些事情你不能通过：例如，channels, functions

	绑定：客户如何知道与谁交谈？
    客户端可能会提供服务器主机名
    也许名称服务将服务名称映射到最佳服务器主机

* RPC问题：失败了如何处理？

例如丢包，断网，服务器慢，服务器崩溃客户端RPC库出现什么样的失败？
	
	客户端从未看到服务器的响应
    
	客户端不知道服务器是否看到请求！
    可能在发送回复之前服务器/网络失败

最简单的方案：“at least once”行为，RPC库等待响应一段时间，如果没有到达，请重新发送请求，做这几次，仍然没有响应 - 向应用程序返回错误

问：应用程序“at least once”保证是否容易实现？

```
简单的问题至少有一次：
  客户发送“从银行账户扣除10美元”

问：这个客户端程序有什么问题吗？
  Put（“k”，10） -  RPC将密钥的值设置在数据库服务器中
  Put（“k”，20） - 客户端然后执行第二个Put到同一个键
  [图，超时，重新发送，原来到达很晚]

问：至少一次好吗？
  是的：如果可以重复操作，例如只读操作
  是的：如果应用程序有自己的应对方案与重复
    您将需要为实验1

更好的RPC行为：“最多一次”
  想法：服务器RPC代码检测到重复的请求
    返回上一个回复，而不是重新运行处理程序
  问：如何检测重复请求？
  客户端包含每个请求的唯一ID（XID）
    使用相同的XID重新发送
  服务器：
    如果看到[xid]：
      r = old [xid]
    其他
      r = handler（）
      老[xid] = r
      见[xid] = true
```

8. 更复杂的问题

	如何确保XID是独一无二的？是采用大随机数还是结合唯一的客户端ID（ip地址？）与序列

    服务器必须最终丢弃有关旧RPC的信息；何时丢弃对于系统是安全？
    
	理念：
      唯一的客户端ID
      每客户端RPC序列号
      客户端包括“每个RPC都看到所有回复<= X”
      很像TCP序列#s和acks

    或者一次只允许客户端一个优秀的RPC
      seq + 1的到达允许服务器丢弃所有<= seq

    或客户同意继续重试<5分钟
      服务器在5分钟以上丢弃
* 如果“at-most-once”服务器崩溃并重新启动，该怎么办？

	如果在内存中重复一次信息，服务器将会忘记;并在重新启动后接受重复的请求
  	
	可能应该将重复的信息写入磁盘？
  	
	可能复制服务器也应该复制重复的信息？

* “at-most-once”呢？
	最多一次加无限制重试加上容错服务（实验3）

* Go RPC是“at-most-once”
	打开TCP连接，写请求到TCP连接，TCP可能重新发送，但服务器的TCP将过滤掉重复，没有重试Go代码（即不会创建第二个TCP连接），如果RPC代码没有得到回复，则返回一个错误（也许在一个超时后（从TCP）;也许服务器没有看到请求；服务器处理的请求可能是服务器/网络失败，在回覆之前）
