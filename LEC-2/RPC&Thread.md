## RPC和线程

最常见的问题：为什么选择GoLang？

1. 6.824用于使用C++

	学生花时间修复与分布式系统无关的错误,例如：他们释放了仍在使用的对象

2. Go允许您专注于分布式系统问题

    良好的并发支持;
    很好的支持RPC;
    垃圾收集（解除后不使用）;
    类型安全.
3. 我们喜欢Go中的编程
	
	简单的语言学习。

Go中的线程是一个有用的结构化工具，Go叫他们goroutines，也有人称其为线程。

为什么线程
  允许您利用并发，它在分布式系统中自然出现
  I / O并发性：
    在等待来自其他服务器的响应时，处理下一个请求
  多核：
    线程在多个内核并行运行

Thread =“执行线程”
  线程允许一个程序（逻辑地）一次执行许多事情
  线程共享内存
  每个线程包括一些每线程状态：
    程序计数器，寄存器，堆栈

程序中有多少个线程？
  鼓励您创建多个线程
    通常比内核更多的线程
    Go运行时可以在可用内核上安排它们
  去线程不是免费的，但你应该考虑一下
    创建线程比方法调用更昂贵
    
线程挑战：
  共享数据 
     一个线程读取另一个线程正在更改的数据？
     可能导致种族条件
     - >不共享或协调共享（例如，互斥）
  线程之间的协调
    例如等待所有Map线程完成
    可能导致死锁（通常比竞赛更容易注意）
    - >使用Go频道或WaitGroup
  并发性的粒度
     粗粒度 - >简单，但并发/并行性很小
     更细微的 - >更多的并发性，更多的种族和僵局
  
演习：两个挑战
1. 安排I / O并发
    在提取网址时，可以使用另一个网址
2. 获取每个URL *一次*
    想避免浪费网络带宽
    希望对远程服务器很好
    =>需要一些跟踪哪些URL访问的方式 
3. [在不同核心上的不同URL上工作]
    不太同意这一点很重要
    
解决方案[see handouts：crawler.go]
  消除深度---使用取而代之
  顺序一：将获取的地图传递给递归调用
    当抓取需要很长时间时，I / O不会重叠
    不利用多个内核
  解决方案与go例程和共享获取的地图
    为每个网址创建一个线程
      我们不会通过什么？（种族）
    为什么锁？（删除它们，每一个似乎都有效！）
      没有锁可以出什么问题？
        检查和标记url不是原子的
    所以可能会发生两次获取相同的URL。
      T1检查抓取[url]，T2检查抓取[url]
      两者都看到该url尚未被抓取
      两者都返回false和两次提取，这是错误的
      这称为*种族条件*
        该bug只显示一些线程交错
    很难找到，很难理解
      去可以检测你的比赛（go run -race crawler.go）
      请注意，访问的检查和标记必须是原子的
    我们如何能够决定我们是否处理一个页面？
      waitGroup
  渠道解决方案
    渠道：一般钱包机制来协调线程
      消息的有界缓冲区
      几个线程可以在频道上发送和接收
        （Go运行时内部使用锁）
    发送或接收可以阻止
      当频道已满时
      当频道为空时
    通过主线程调度每个url提取
      没有比赛获取地图，因为它不共享！

什么是最好的解决方案？
  所有并发的数据比串行数据更加困难
  有些Go设计师认为避免共享内存
    即只使用频道
  我的实验室解决方案使用许多并发功能
    锁定时共享是自然的
      例如，几个服务器线程共享地图
    线程之间的协调通道
      例如，生产者/消费者风格的并发
  使用Go的比赛检测器：
    https://golang.org/doc/articles/race_detector.html
    去测试-race mypkg

远程过程调用（RPC）
  分布式系统的关键部分; 所有实验室都使用RPC
  目标：易于编程的网络通信
    隐藏客户端/服务器通信的大部分细节
    客户端调用很像普通程序调用
    服务器处理程序很像普通程序
  RPC被广泛使用！

RPC理想地使净通信看起来像fn调用：
  客户：
    z = fn（x，y）
  服务器：
    fn（x，y）{
      计算
      返回z
    }
  RPC旨在实现这种透明度

例如：kv.go [见讲义：kv.go]
  客户端“拨号”服务器并调用Call（）
    调用类似于常规函数调用
  服务器在单独的线程中处理每个请求
    并发！因此，锁定键值。

RPC消息图：
  客户端服务器
    请求--->
       <---响应

软件结构
  客户端应用处理程序
    存根调度器
   RPC lib RPC lib
     净------------网
 
几个细节：
  哪个服务器功能（处理程序）调用？
    在Go中指定的Go（）
  编组：将数据格式化成数据包
    针对数组，指针，对象和c
    Go的RPC库非常强大！
    有些事情你不能通过：例如，渠道，功能
  绑定：客户如何知道与谁交谈？
    客户端可能会提供服务器主机名
    也许名称服务将服务名称映射到最佳服务器主机

RPC问题：怎么做失败？
  例如丢包，断网，服务器慢，服务器崩溃

客户端RPC库出现什么样的失败？
  客户端从未看到服务器的响应
  客户端不*不知道服务器是否看到请求！
    可能在发送回复之前服务器/网络失败
  [丢失回复图]

最简单的方案：“至少一次”行为
  RPC库等待响应一段时间
  如果没有到达，请重新发送请求
  做这几次
  仍然没有响应 - 向应用程序返回错误

问：应用程序是否“至少一次”易于应对？

简单的问题至少有一次：
  客户发送“从银行账户扣除10美元”

问：这个客户端程序有什么问题吗？
  Put（“k”，10） -  RPC将密钥的值设置在数据库服务器中
  Put（“k”，20） - 客户端然后执行第二个Put到同一个键
  [图，超时，重新发送，原来到达很晚]

问：至少一次好吗？
  是的：如果可以重复操作，例如只读操作
  是的：如果应用程序有自己的应对方案与重复
    您将需要为实验1

更好的RPC行为：“最多一次”
  想法：服务器RPC代码检测到重复的请求
    返回上一个回复，而不是重新运行处理程序
  问：如何检测重复请求？
  客户端包含每个请求的唯一ID（XID）
    使用相同的XID重新发送
  服务器：
    如果看到[xid]：
      r = old [xid]
    其他
      r = handler（）
      老[xid] = r
      见[xid] = true

最复杂的一些
  这将在实验室3及以后出现
  如何确保XID是独一无二的？
    大随机数？
    结合唯一的客户端ID（ip地址？）与序列号＃
  服务器必须最终丢弃有关旧RPC的信息
    何时丢弃安全？
    理念：
      唯一的客户端ID
      每客户端RPC序列号
      客户端包括“每个RPC都看到所有回复<= X”
      很像TCP序列#s和acks
    或者一次只允许客户端一个优秀的RPC
      seq + 1的到达允许服务器丢弃所有<= seq
    或客户同意继续重试<5分钟
      服务器在5分钟以上丢弃
  原件仍在执行时如何处理dup请求？
    服务器不知道回复了 不想跑两次
    想法：每个执行RPC的“挂起”标志; 等待或忽略

如果最多一次服务器崩溃并重新启动，该怎么办？
  如果在内存中重复一次信息，服务器将会忘记
    并在重新启动后接受重复的请求
  也许应该将重复的信息写入磁盘？
  也许复制服务器也应该复制重复的信息？

“一次”呢？
  最多一次加无限制重试加上容错服务
  实验3

Go RPC是“最多一次”
  打开TCP连接
  写请求到TCP连接
  TCP可能重新发送，但服务器的TCP将过滤掉重复
  没有重试Go代码（即不会创建第二个TCP连接）
  如果RPC代码没有得到回复，则返回一个错误
    也许在一个超时后（从TCP）
    也许服务器没有看到请求
    服务器处理的请求可能是服务器/网络失败，在回覆之前
